<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>Vue | Lightman&#39;s blog</title>
  <meta name="description" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" type="text/css" href="/css/component.css" />
  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <meta name="generator" content="Lightman's blog">
  <script src="http://static.duoshuo.com/embed.js"></script>
  
  
  

  

</head>
<body>
<div class="container">
    <div class="mp-pusher" id="mp-pusher">
        <i id="scroll-up" class="fa fa-angle-up"></i>
        <nav id="mp-menu" class="mp-menu">
            <div class="mp-level">
                <a data-pjax class="back-home" style="font-size: 20px" href="/"><h2 ><i class="fa fa-home"></i>
                        Home</h2></a>
                <ul class="first-level">
                    <li>
                        <a class="fa fa-archive" href="#"><i class="fa fa-angle-left">
                            </i>&nbsp;&nbsp;Archive</a>
                        <div class="mp-level page-list">
                            <h2 ><i class="fa fa-archive"></i>
                                Archive</h2>
                            <a class="mp-back" href="#">back</a>
                            <form id="search-form" action="">
                                <input type="text" class="search search-archive" placeholder="Search.."/>
                            </form>
                            <ul>
                                <div class="mp-scroll">
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2020/12/01/Typescript/">Typescript 学习笔记</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2020/06/17/Vue/">Vue</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2020/02/17/V开场台词/">V 开场自我介绍</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/AdvancedAutoEncoder/">AdvancedAutoEncoder</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/AutoEncoder/">AutoEncoder</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/CNNAutoEncoder/">卷积自编码器</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/CNN/">卷积神经网络</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/EnglishPronunciation/">连读规则</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/GAN/">GAN网络代码</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/Git/">Git教程</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/JavaScript高级程序设计/">JavaScript 高级程序设计</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/LSTM/">LSTM简介及代码</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/Ted_给陌生人的情书/">汉娜·布伦雪尔：给陌生人的情书</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/ReinforcementLearning/">强化学习简介</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/STGCN/">时空图卷积网络</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/沉默的大多数/">沉默的大多数</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/算法/">算法速查</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/12/23/python/">Python教程</a>
                                </li>
                                
                                <li class="search-archive-li mp-pjax">
                                    <a href="/2019/01/23/Flex/">Flex 布局</a>
                                </li>
                                
                                </div>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a class="fa fa-copy" href="#"><i class="fa fa-angle-left">
                            </i>&nbsp;&nbsp;Categories</a>

                        <div class="mp-level page-list">
                            <h2 ><i class="fa fa-copy"></i>
                                Categories</h2>
                            <a class="mp-back" href="#">back</a>
                            <form id="search-form" action="">
                                <input type="text" class="search search-category" placeholder="Search.."/>
                            </form>
                            <ul>
                                <div class="mp-scroll">
                                
                                <li class="search-category-li mp-pjax">
                                    <a href="/categories/前端技术/">&nbsp;&nbsp;&nbsp;前端技术</a>
                                    <small>3</small>
                                </li>
                                
                                <li class="search-category-li mp-pjax">
                                    <a href="/categories/后台技术/">&nbsp;&nbsp;&nbsp;后台技术</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-category-li mp-pjax">
                                    <a href="/categories/常用技术/">&nbsp;&nbsp;&nbsp;常用技术</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-category-li mp-pjax">
                                    <a href="/categories/强化学习/">&nbsp;&nbsp;&nbsp;强化学习</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-category-li mp-pjax">
                                    <a href="/categories/深度学习/">&nbsp;&nbsp;&nbsp;深度学习</a>
                                    <small>7</small>
                                </li>
                                
                                <li class="search-category-li mp-pjax">
                                    <a href="/categories/算法/">&nbsp;&nbsp;&nbsp;算法</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-category-li mp-pjax">
                                    <a href="/categories/英语/">&nbsp;&nbsp;&nbsp;英语</a>
                                    <small>3</small>
                                </li>
                                
                                <li class="search-category-li mp-pjax">
                                    <a href="/categories/读书笔记/">&nbsp;&nbsp;&nbsp;读书笔记</a>
                                    <small>1</small>
                                </li>
                                
                                </div>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a class="fa fa-tags" href="#"><i class="fa fa-angle-left">
                            </i>&nbsp;&nbsp;Tags</a>
                        <div class="mp-level page-list">
                            <h2 ><i class="fa fa-tags"></i>
                                Tags</h2>
                            <a class="mp-back" href="#">back</a>
                            <form id="search-form" action="">
                                <input type="text" class="search search-tag" placeholder="Search.."/>
                            </form>
                            <ul>
                                <div class="mp-scroll">
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/AutoEncoder/">&nbsp;&nbsp;&nbsp;AutoEncoder</a>
                                    <small>3</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/CNN/">&nbsp;&nbsp;&nbsp;CNN</a>
                                    <small>2</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/Flex/">&nbsp;&nbsp;&nbsp;Flex</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/GAN/">&nbsp;&nbsp;&nbsp;GAN</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/GCN/">&nbsp;&nbsp;&nbsp;GCN</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/JavaScript/">&nbsp;&nbsp;&nbsp;JavaScript</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/LSTM/">&nbsp;&nbsp;&nbsp;LSTM</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/Python/">&nbsp;&nbsp;&nbsp;Python</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/Q网络/">&nbsp;&nbsp;&nbsp;Q网络</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/Ted/">&nbsp;&nbsp;&nbsp;Ted</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/Typescript/">&nbsp;&nbsp;&nbsp;Typescript</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/协作开发软件/">&nbsp;&nbsp;&nbsp;协作开发软件</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/沉默的大多数/">&nbsp;&nbsp;&nbsp;沉默的大多数</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/电影台词/">&nbsp;&nbsp;&nbsp;电影台词</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/算法/">&nbsp;&nbsp;&nbsp;算法</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li mp-pjax">
                                    <a href="/tags/连读发音/">&nbsp;&nbsp;&nbsp;连读发音</a>
                                    <small>1</small>
                                </li>
                                
                                </div>
                            </ul>
                        </div>
                    </li>
                    
                    <li class="mp-pjax"><a class="fa fa-user" href="/about">&nbsp;&nbsp;&nbsp;About me</a></li>
                    <li><a class="fa fa-github" href="#">&nbsp;&nbsp;&nbsp;Github</a></li>

                </ul>

            </div>
        </nav>
        <div id="pjax">
            <div class="pjax-hidden" style="display: none">
                
                    <a  data-pjax href="/2020/12/01/Typescript/">Typescript 学习笔记</a>
                
                    <a  data-pjax href="/2020/06/17/Vue/">Vue</a>
                
                    <a  data-pjax href="/2020/02/17/V开场台词/">V 开场自我介绍</a>
                
                    <a  data-pjax href="/2019/12/23/AdvancedAutoEncoder/">AdvancedAutoEncoder</a>
                
                    <a  data-pjax href="/2019/12/23/AutoEncoder/">AutoEncoder</a>
                
                    <a  data-pjax href="/2019/12/23/CNNAutoEncoder/">卷积自编码器</a>
                
                    <a  data-pjax href="/2019/12/23/CNN/">卷积神经网络</a>
                
                    <a  data-pjax href="/2019/12/23/EnglishPronunciation/">连读规则</a>
                
                    <a  data-pjax href="/2019/12/23/GAN/">GAN网络代码</a>
                
                    <a  data-pjax href="/2019/12/23/Git/">Git教程</a>
                
                    <a  data-pjax href="/2019/12/23/JavaScript高级程序设计/">JavaScript 高级程序设计</a>
                
                    <a  data-pjax href="/2019/12/23/LSTM/">LSTM简介及代码</a>
                
                    <a  data-pjax href="/2019/12/23/Ted_给陌生人的情书/">汉娜·布伦雪尔：给陌生人的情书</a>
                
                    <a  data-pjax href="/2019/12/23/ReinforcementLearning/">强化学习简介</a>
                
                    <a  data-pjax href="/2019/12/23/STGCN/">时空图卷积网络</a>
                
                    <a  data-pjax href="/2019/12/23/沉默的大多数/">沉默的大多数</a>
                
                    <a  data-pjax href="/2019/12/23/算法/">算法速查</a>
                
                    <a  data-pjax href="/2019/12/23/python/">Python教程</a>
                
                    <a  data-pjax href="/2019/01/23/Flex/">Flex 布局</a>
                
                
                    <a data-pjax href="/categories/前端技术/">&nbsp;&nbsp;前端技术</a>
                
                    <a data-pjax href="/categories/后台技术/">&nbsp;&nbsp;后台技术</a>
                
                    <a data-pjax href="/categories/常用技术/">&nbsp;&nbsp;常用技术</a>
                
                    <a data-pjax href="/categories/强化学习/">&nbsp;&nbsp;强化学习</a>
                
                    <a data-pjax href="/categories/深度学习/">&nbsp;&nbsp;深度学习</a>
                
                    <a data-pjax href="/categories/算法/">&nbsp;&nbsp;算法</a>
                
                    <a data-pjax href="/categories/英语/">&nbsp;&nbsp;英语</a>
                
                    <a data-pjax href="/categories/读书笔记/">&nbsp;&nbsp;读书笔记</a>
                
                
                    <a data-pjax href="/tags/AutoEncoder/">&nbsp;&nbsp;AutoEncoder</a>
                
                    <a data-pjax href="/tags/CNN/">&nbsp;&nbsp;CNN</a>
                
                    <a data-pjax href="/tags/Flex/">&nbsp;&nbsp;Flex</a>
                
                    <a data-pjax href="/tags/GAN/">&nbsp;&nbsp;GAN</a>
                
                    <a data-pjax href="/tags/GCN/">&nbsp;&nbsp;GCN</a>
                
                    <a data-pjax href="/tags/JavaScript/">&nbsp;&nbsp;JavaScript</a>
                
                    <a data-pjax href="/tags/LSTM/">&nbsp;&nbsp;LSTM</a>
                
                    <a data-pjax href="/tags/Python/">&nbsp;&nbsp;Python</a>
                
                    <a data-pjax href="/tags/Q网络/">&nbsp;&nbsp;Q网络</a>
                
                    <a data-pjax href="/tags/Ted/">&nbsp;&nbsp;Ted</a>
                
                    <a data-pjax href="/tags/Typescript/">&nbsp;&nbsp;Typescript</a>
                
                    <a data-pjax href="/tags/协作开发软件/">&nbsp;&nbsp;协作开发软件</a>
                
                    <a data-pjax href="/tags/沉默的大多数/">&nbsp;&nbsp;沉默的大多数</a>
                
                    <a data-pjax href="/tags/电影台词/">&nbsp;&nbsp;电影台词</a>
                
                    <a data-pjax href="/tags/算法/">&nbsp;&nbsp;算法</a>
                
                    <a data-pjax href="/tags/连读发音/">&nbsp;&nbsp;连读发音</a>
                
                <a data-pjax class="fa fa-user" href="/about">&nbsp;&nbsp;&nbsp;About me</a>
            </div>
            <nav class="nexus">
                <li  style="border-left: 1px solid #c6d0da;">
                    <a id="trigger" href="#"><i class="fa fa-bars"></i></a>
                </li>
                <li ><a id="nexus-back" data-pjax href="/">Lightman&#39;s blog</a></li>
                
                <div id="nav-container">
                    <div class="post-navbar" style="line-height: 63px;display:none">
                        <li id="navbar-title"><a href="#">Vue</a></li>
                        <li id="navbar-toc" style="border-left: none">
                            <a style="padding-right: 15px">
                                <span id="toc-content" >Introduction</span><i class="fa fa-chevron-down" ></i>
                            </a>
                            <div class="hidden-box">
                                <ul id="toc"></ul>
                            </div>
                        </li>
                    </div>
                </div>
                
            </nav>

            <div class="scroller">
            <div class="scroller-inner">


<!-- -->
<!--<body class="post-template">-->
<!---->
  

<main class="content" role="main">
    <article class="post" >
    <span class="post-meta">
                  <div class="tag-tile">
                      
                  </div>
                <h1 class="post-title" style="margin: 14px 0;color:#50585D">Vue</h1>

                    <div class="post-meta">
                        Post on<span class="fa fa-clock-o"></span>
                        <time datetime="2020-06-17T11:03:09.673Z"
                              itemprop="datePublished">2020-06-17</time>
                    </div>
    </span>

        <section class="post-content">
            <p>[TOC]</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><ol>
<li>DOM里边使用定义的别名，需要在前边加上“~”</li>
<li>this.$router 拿到的是vue-router这个对象，this.$route 拿到的是当前哪个路由处于活跃状态</li>
</ol>
<h3 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a><strong>ES6语法</strong></h3><ul>
<li>ES6除了’’和””以外，还可以使用``（TAB上边的那个点）来定义字符串，他的好处是可以直接回车换行</li>
</ul>
<h3 id="1-计算属性"><a href="#1-计算属性" class="headerlink" title="1. 计算属性"></a>1. 计算属性</h3><ul>
<li>计算属性(computed)本质上是一个属性，它有getter和setter，但是我们在使用时只是实现了getter，而没有实现setter</li>
<li>计算属性在使用多次时，只会调用1次（因为他是有缓存的，效率比methods要高）</li>
<li>v-show与v-if的区别：v-show是修改diplay属性，而v-if是dom是否渲染，是否存在</li>
</ul>
<h3 id="2-JavaScript高阶函数"><a href="#2-JavaScript高阶函数" class="headerlink" title="2. JavaScript高阶函数"></a>2. JavaScript高阶函数</h3><ul>
<li><h5 id="回调函数："><a href="#回调函数：" class="headerlink" title="回调函数："></a>回调函数：</h5><ul>
<li>被用于高级函数里边，作为参数传给高级函数的函数就称为回调函数。</li>
<li>还有一种说法是，用来规范js函数的调用顺序。</li>
</ul>
</li>
<li><h5 id="obj-filter-callbackfn"><a href="#obj-filter-callbackfn" class="headerlink" title="obj.filter(callbackfn)"></a>obj.filter(callbackfn)</h5><ul>
<li>参数为回调函数，对obj执行callbackfn进行过滤</li>
</ul>
</li>
<li><h5 id="obj-map"><a href="#obj-map" class="headerlink" title="obj.map()"></a>obj.map()</h5><ul>
<li>对obj进行操作</li>
</ul>
</li>
<li><h5 id="obj-reduce"><a href="#obj-reduce" class="headerlink" title="obj.reduce()"></a>obj.reduce()</h5><ul>
<li>对obj进行汇总</li>
</ul>
</li>
</ul>
<h3 id="3-v-model"><a href="#3-v-model" class="headerlink" title="3. v-model"></a>3. v-model</h3><ul>
<li>label要想互斥（只能2选1），要给label里边的input的name属性赋相同的值</li>
<li>在vue里边，如果给label里边的input的value属性绑定相同的data也可以互斥</li>
<li><strong>v-model本质为，v-bind:value + v-on:input=”data = $event.target.value”</strong></li>
<li>v-model绑定checkbox，绑定单个值，data为boolean类型。绑定多个值时，只需要给data设置为[](list类型)即可</li>
<li><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><ul>
<li>lazy：v-model是实时绑定的，当使用v-model.lazy时，可以实现用户敲回车或者点击空白（失去焦点）的时候再进行刷新绑定</li>
<li>number：v-model进行值绑定时，默认为string类型，这时候使用v-model.number</li>
<li>trim：v-model去掉多余的空格</li>
</ul>
</li>
</ul>
<h3 id="4-组件化"><a href="#4-组件化" class="headerlink" title="4. 组件化"></a>4. 组件化</h3><ul>
<li><h5 id="什么是组件化？"><a href="#什么是组件化？" class="headerlink" title="什么是组件化？"></a>什么是组件化？</h5><ul>
<li>将大的问题拆成一个又一个小的问题去解决</li>
</ul>
</li>
<li><h5 id="Vue的组件化思想"><a href="#Vue的组件化思想" class="headerlink" title="Vue的组件化思想"></a>Vue的组件化思想</h5><ul>
<li>可以让我们用一个又一个独立可复用的小组件来完成我们的应用</li>
<li>任何应用都可以抽象成一个组件树（Vue官方有图）</li>
</ul>
</li>
<li><h5 id="全局组件与局部组件"><a href="#全局组件与局部组件" class="headerlink" title="全局组件与局部组件"></a>全局组件与局部组件</h5><ul>
<li><p>Vue.extend()来编写组件的构造器，但是现在用的很少了，一般直接使用语法糖</p>
<pre><code>const myComponent = Vue.extend({
    template: 
    `
        &lt;div&gt;lalalalal&lt;/div&gt;
    `
})
Vue.component(&apos;cp1&apos;, myComponent)  #这里注册</code></pre></li>
<li><p>通过Vue.component(‘标签名’,组件)来注册的组件为全局组件</p>
</li>
<li><p>在Vue示例当中，也就是new Vue({components:})里边注册的组件为局部组件</p>
</li>
<li><p>组件注册的语法糖</p>
<ul>
<li><p>就是省略Vue.extend()</p>
<pre><code>Vue.component(&apos;cp1&apos;, {
    template: 
    `
        &lt;div&gt;lalalalal&lt;/div&gt;
    `
})</code></pre></li>
</ul>
</li>
<li><p>v-bind不能识别驼峰，要将驼峰进行转换，mustache是可以识别驼峰的</p>
</li>
</ul>
</li>
<li><h4 id="组件之间传值"><a href="#组件之间传值" class="headerlink" title="#组件之间传值"></a>#组件之间传值</h4><ul>
<li><p>父传子：在子组件的props中定义数据（也可以称之为变量），然后在使用的时候绑定即可</p>
<pre><code>例如：你在子组件中定义了name
props: {
    name: String  //这里的String是限制传过来的数据类型，可以不写
}
或者
props: {
    name: {
        type: String,
        default: 这是默认值
    }
}
然后在使用的地方加上name属性即可，例如cpn组件
&lt;cpn name=&apos;我是一个字符串&apos;&gt;&lt;/cpn&gt;
&lt;cpn :name=&apos;父组件中的属性&apos;&gt;&lt;/cpn&gt;     //使用v-bind来绑定父组件中的属性</code></pre></li>
<li><p>子传父：例如子组件为<cpn>。 使用自定义事件，this.$emit(‘传递的名称’, 传递的参数)，然后在组件进行监听&lt;cpn @传递的名称=’父组件的函数’&gt;  </p>
<pre><code>this.$emit(&apos;btnClick&apos;, item)
&lt;cpn @btnClick=&apos;cpnClick(item)&apos;&gt;    
#(item)可以省略，系统默认把子组件传递的参数传给父组件
#其实这里也是不能用驼峰的，但是脚手架里貌似可以用</code></pre><p>例如，点击button时向父组件传递数据</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;button @click=&quot;btnClick&quot;&gt;&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
methods: {
    btnClick() {
        this.$emit(&apos;随便起的名称&apos;, 这是数据)
    }
}

&lt;cpn @随便起的名称=&quot;父组件的函数(这里是数据)&quot;&gt;&lt;/cpn&gt;</code></pre></li>
</ul>
</li>
</ul>
<h3 id="5-父子组件间的访问方式"><a href="#5-父子组件间的访问方式" class="headerlink" title="5. 父子组件间的访问方式"></a>5. 父子组件间的访问方式</h3><pre><code>有时候父组件需要直接访问子组件，而不是使用props通信的方式，子组件需要直接访问父组件或者根组件</code></pre><ul>
<li><h5 id="父组件访问子组件"><a href="#父组件访问子组件" class="headerlink" title="父组件访问子组件"></a>父组件访问子组件</h5><ul>
<li><p>$children 在父组件的methods里边任意的函数里边this.$children即可获取子组件，返回的是一个数组（在开发时一般不使用这个方法，只有我们需要拿所有子组件时才可能会用，一般使用$refs）</p>
</li>
<li><p>$refs 这个需要在子组件加一个ref属性，然后再在methods里边调用，默认时为空[]</p>
<pre><code>&lt;cpn ref=&apos;aaa&apos;&gt;&lt;/cpn&gt;
this.$refs.aaa</code></pre></li>
</ul>
</li>
<li><h5 id="子组件访问父组件"><a href="#子组件访问父组件" class="headerlink" title="子组件访问父组件"></a>子组件访问父组件</h5><ul>
<li>$parent 用的更少，因为不好复用，不建议使用，在子组件里this.$parent,</li>
<li>$root 访问根组件</li>
</ul>
</li>
</ul>
<h3 id="6-插槽"><a href="#6-插槽" class="headerlink" title="6. 插槽"></a>6. 插槽</h3><ul>
<li><h5 id="slot基本使用"><a href="#slot基本使用" class="headerlink" title="slot基本使用"></a>slot基本使用</h5><ul>
<li><p><slot></slot> 如果在插槽中放东西，就是设置默认值，例如:</p>
<pre><code>&lt;slot&gt;&lt;button&gt;&lt;/button&gt;&lt;/slot&gt;</code></pre><p>如果在使用组件时，没有使用插槽，就会显示默认值，使用了，就显示你想要的值</p>
</li>
</ul>
</li>
<li><h5 id="具名插槽slot"><a href="#具名插槽slot" class="headerlink" title="具名插槽slot"></a>具名插槽slot</h5><ul>
<li><slot name=''></slot>，在使用时要给使用的地方加slot属性，例如 <span slot='这里是我们插槽的名字'></span></li>
</ul>
</li>
<li><h5 id="作用域插槽slot"><a href="#作用域插槽slot" class="headerlink" title="作用域插槽slot"></a>作用域插槽slot</h5><ul>
<li><p>父组件替换插槽里边的标签，但是内容是由子组件来提供， 例如cpn组件里边有一个languages的list</p>
<pre><code>&lt;cpn&gt;
    &lt;template slot=&apos;具名插槽&apos; slot-scope=&apos;myData&apos;&gt;  #这里的slot是可选选项，也就是说，作用域插槽可以用到具名插槽里边，myData也相当于是一个变量名称，可以随意定
        &lt;span&gt;{{myData.languages}}&lt;/span&gt;   #在这里使用这种形来调用子组件中的数据
    &lt;/template&gt;
&lt;/cpn&gt;

&lt;template id=&apos;cpn&apos;&gt;
    &lt;slot :data=&apos;languages&apos;&gt;&lt;/slot&gt;         #这里的data可以为任意名称，这里相当于声明一个变量
&lt;/template&gt;

cpn: {
    template: &quot;#cpn&quot;
    data: {
        return {
            languages : [&apos;java&apos;,&apos;java&apos;,&apos;java&apos;]
        }
    }
}</code></pre></li>
</ul>
</li>
</ul>
<h3 id="7-模块化开发"><a href="#7-模块化开发" class="headerlink" title="7. 模块化开发"></a>7. 模块化开发</h3><ul>
<li><h5 id="ES5模块化"><a href="#ES5模块化" class="headerlink" title="ES5模块化"></a>ES5模块化</h5><ul>
<li>ES5没有模块化，所以使用匿名函数的解决方案</li>
</ul>
</li>
<li><h5 id="常见的模块化规范"><a href="#常见的模块化规范" class="headerlink" title="常见的模块化规范"></a>常见的模块化规范</h5><ul>
<li><p>CommonJS、AMD、CMD、ES6的Modules</p>
</li>
<li><p>CommenJS(Webpack和Node.js用的多)：</p>
<ul>
<li><p>导出：</p>
<pre><code>module.exports = {
    flat: true,
    test(a, b){
        return a + b
    }
}</code></pre></li>
<li><p>导入：</p>
<pre><code>let obj = require(&apos;xxx.js&apos;) 
let {flat, tent} = require(&apos;xxx.js&apos;) 也可以直接获取</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><h5 id="ES6的模块化"><a href="#ES6的模块化" class="headerlink" title="ES6的模块化"></a>ES6的模块化</h5><ul>
<li><p>模块化就是在script标签里边的type属性定义为module，然后在该js文件里边export导出，在使用的地方import导入即可，例如: import {name} from ‘xxx.js’</p>
  <script type="module"></script>
</li>
<li><p>export default： 某些情况下，某个模块包含某个功能，我们并不希望给这个功能命名，而且让导入者自己命名，这时候我们就可以使用export default，<strong>一个js文件中只能有一个export default不允许存在多个，并且它后边只能跟一个值或对象</strong>，这里再使用import时可以不用使用{}了，直接为： import 我自己的命名 from ‘xxx.js’</p>
</li>
<li><p>当我们需要导入的东西太多时，例如:</p>
<pre><code>import {name,age,aaa,bbb,ccc,ddd} from &apos;aaa.js&apos;</code></pre><p>  我们可以使用</p>
<pre><code>import * as myName from &apos;aaa/js&apos;
myName.name</code></pre></li>
</ul>
</li>
</ul>
<h3 id="8-Webpack"><a href="#8-Webpack" class="headerlink" title="8. Webpack"></a>8. Webpack</h3><ul>
<li><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><ul>
<li><p>项目中要使用node依赖包时，要使用npm init命令安装依赖，这时候系统会生成package.json</p>
</li>
<li><p>webpack进行打包时，要有一个入口文件，例如main.js，在这个里边对你使用的各个文件，各个模块进行使用或者导入，然是在使用webpack对入口文件进行打包，webpack会自动处理与入口文件有关的各个模块各个依赖，然后进行打包，打包完成之后，webpack会生成一个js，在你想使用的页面中，使用打包后的js即可</p>
<pre><code>require(&apos;./css/normal.css&apos;)
require(&apos;./css/special.less&apos;)
const {param1, param2} = require(./js/abc.js)  param1和param2为接收的变量</code></pre></li>
</ul>
</li>
</ul>
<pre><code>- webpack.config.js是webpack的配置文件，在里边对其进行配置，包括entry，output，loader等

        const path = require(&apos;path&apos;)
        module.exports = {
            entry: &apos;.src/main.js&apos;,
            output: {
                // path: 这里必须是绝对地址，path是node的一个库，__dirname是获取本文件的绝对路径，path.resolve是拼接路径
                path: path.resolve(__dirname, &apos;dist&apos;)
                filename: &apos;bundle.js&apos;
            }   
        }

- package.json里的scripts里边定义的指令，优先使用本地库，如果没有本地库才去找全局库，在所有cmd中，都优先使用全局库，所以当我们想使用本地库时，在package.json里边定义指令即可
- npm install webpack --save-dev (--save-dev 是开始时依赖的意思，打包之后不用)</code></pre><ul>
<li><h5 id="核心为loader，可以在官方文档里边查找使用方法，用来处理各个文件，进行打包"><a href="#核心为loader，可以在官方文档里边查找使用方法，用来处理各个文件，进行打包" class="headerlink" title="核心为loader，可以在官方文档里边查找使用方法，用来处理各个文件，进行打包"></a>核心为loader，可以在官方文档里边查找使用方法，用来处理各个文件，进行打包</h5><ul>
<li>webpack 使用多个loader时，它是从右向左读取的</li>
<li>url-loader 在使用时，options里边有一个limit选项，这里边限制了图片的大小，如果小于这个限制，url-loader会把图片编译成base64格式进行使用，大于这个限制还需要下载一个file-loader</li>
<li>ES6 To ES5     <strong>babel-loader 脚手架里会有详细配置</strong></li>
<li>vue<ul>
<li>npm install vue-loader vue-template-compiler –save-dev 安装 </li>
<li>再到 webpack.config.js里边进行配置</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="plugin-在js文件里添加版权信息，webpack-BannerPlugin"><a href="#plugin-在js文件里添加版权信息，webpack-BannerPlugin" class="headerlink" title="plugin 在js文件里添加版权信息，webpack.BannerPlugin"></a>plugin 在js文件里添加版权信息，webpack.BannerPlugin</h5><pre><code>const webpack = require(&apos;webpack&apos;)
module.exports = {
    plugins: [
        new webpack.BannerPlugin(&apos;最终版权归xxx所有&apos;)
    ]
}</code></pre></li>
<li><h5 id="HtmlWebpackPlugin-插件"><a href="#HtmlWebpackPlugin-插件" class="headerlink" title="HtmlWebpackPlugin 插件"></a>HtmlWebpackPlugin 插件</h5><ul>
<li><p>在dist文件（我们发布的文件）里边自动生成一个index.html文件（可以使用指定模板）</p>
</li>
<li><p>将打包的标签自动添加到body中的script标签当中</p>
</li>
<li><p>安装</p>
<pre><code>npm install html-webpack-plugin --save-dev</code></pre></li>
<li><p>使用</p>
<pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)
module.exports = {
    plugins: [
        new webpack.BannerPlugin(&apos;最终版权归xxx所有&apos;)
        new HtmlWebpackPlugin()  //也可以有参数
        new HtmlWebpackPlugin({
            template: &apos;index.html&apos;  //根据index.html来生成，他会在当前的配置文件webpack.config.js所在的目录下找index.html，然后作为模板来生成
        })
    ]
}   </code></pre></li>
<li><p>js压缩的plugin</p>
<ul>
<li>uglifyjs-webpack-plugin</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="webpack-dev-server搭建本地服务器"><a href="#webpack-dev-server搭建本地服务器" class="headerlink" title="webpack-dev-server搭建本地服务器"></a>webpack-dev-server搭建本地服务器</h5><ul>
<li><p>这个本地服务器基于node.js，内部使用express框架</p>
</li>
<li><p>安装： npm install webpack-dev-server –save-dev</p>
</li>
<li><p>配置：</p>
<pre><code>module.exports = {
    devServer: {
        contentBase: &apos;./dist&apos;,      //要服务于那个文件夹
        inline: true                //是否实时刷新
        port: 1234                  //还可以配置端口，默认为8080
    }
}</code></pre></li>
<li><p>使用： 在package.json的scripts里边加上</p>
<pre><code>&quot;scripts&quot;: {
    &quot;serve&quot;: &quot;webpack-dev-server --open&quot;    //--open的作用是在跑完webpack-dev-server后，自动打开网页
}</code></pre></li>
</ul>
</li>
<li><h5 id="给文件夹起别名"><a href="#给文件夹起别名" class="headerlink" title="给文件夹起别名"></a>给文件夹起别名</h5><ul>
<li><p>在webpack.base.config.js里边的resolve属性的alias属性里边起别名</p>
<pre><code>resolve: {
    alias: {
        &apos;@&apos;: resolve(&apos;src&apos;)         //相当于给src起了别名为@，当我们使用/src/name时可以使用@/name
    }
}</code></pre><p>  在组件的script里边可以直接使用 import aaa from ‘@/name’<br>  <strong>注意：</strong>当我们的路径在dom里边使用，比如img里边，因为是src，所以不能直接使用，要使用~</p>
<pre><code>&lt;img src=&quot;~@/name&quot;&gt;</code></pre></li>
</ul>
</li>
</ul>
<h3 id="9-Vue-CLI"><a href="#9-Vue-CLI" class="headerlink" title="9. Vue CLI"></a>9. Vue CLI</h3><ul>
<li><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul>
<li>现在一般情况是使用的都是3.x的版本，通过 npm install @vue/cli -g来安装</li>
<li>如果即想用2的模板进行创建，也想用3的，就需要拉取2的模板，使用 npn install @vue/cli-init -g来进行安装</li>
</ul>
</li>
<li><h5 id="Vue-CLI2初始化项目"><a href="#Vue-CLI2初始化项目" class="headerlink" title="Vue CLI2初始化项目"></a>Vue CLI2初始化项目</h5><ul>
<li><p>指令：</p>
<pre><code>vue init webpack myProject</code></pre></li>
<li><p>配置项：</p>
<ul>
<li>Project name: package.json中的项目的名称，直接敲回车的话，默认为初始化的名字</li>
<li>Project description: 项目描述，保存在package.json中</li>
<li>Author</li>
<li>Vue build: 使用哪个版本的vue<ul>
<li>Runtime-only版本不能使用template，可能会导致项目不能运行，<ul>
<li>优点：它更小，运行效率更高，性能更高</li>
</ul>
</li>
<li>Runtime + Compiler 适合大多数使用者</li>
<li><strong>区别</strong>： <ul>
<li>main.js里边有区别，compiler使用了template，runtime-only使用了render箭头函数，自动生成时为h函数(本质为createElement函数，参数有三个(‘标签名’，{标签的属性}, [标签的内容]))</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>                    createElement(&apos;div&apos;, {class: &apos;box&apos;}, [&apos;hello&apos;, createElement(...)])   //内容里边可以继续嵌套
                    createElement(cpn)      //也可以直接放入一个组件效果一样，但是因为省略的ast步骤，效率更高

            - compiler里边的vue的运行过程：template -&gt; ast(abstract syntax tree抽象语法树) -&gt; render函数 -&gt; virtual DOM -&gt; real DOM(UI)
            - runtime-only的运行过程为： render函数 -&gt; virtual DOM -&gt; real DOM(UI)
            - 对比的话，only的性能更高，vue内部的代码量更少（因为它不需要写template -&gt; ast(abstract syntax tree抽象语法树) -&gt; render函数的处理的代码），runtime-only的.vue文件里边的template不需要使用template -&gt;ast，而是由vue-template-compiler这个库自己帮我们解析成了render函数
    + vue-router: 
    + ESLint: 是否使用ESLint对代码进行规范（ESLint当代码不规范时，编译直接报错）
    + unit test: 单元测试
    + e2e test with Nightwatch: end to end 使用Nightwatch进行端到端测试
- **package-lock.json**：记录node_modules里安装的真实版本，在package.json（这里只会规定一个大概的版本）里边有时候要求的安装版本与node_modules里安装的会不同，这里进行记录
- static文件：在build后，会原封不动的复制到dist文件当中</code></pre><ul>
<li><h5 id="Vue-CLI3初始化项目"><a href="#Vue-CLI3初始化项目" class="headerlink" title="Vue CLI3初始化项目"></a>Vue CLI3初始化项目</h5><ul>
<li><p>指令：</p>
<pre><code>vue create myProject</code></pre></li>
<li><p>配置项(按空格是选择或者取消)：</p>
<ul>
<li>please pick a preset<ul>
<li>default(babel, ESlint)</li>
<li>Manually</li>
</ul>
</li>
<li>自己看吧。。。</li>
</ul>
</li>
<li><p>public文件夹：在build后，原封不动的复制到dist当中</p>
</li>
<li><p>Vue CLI3的配置文件的修改方式：</p>
<ul>
<li>Vue UI：图形化界面进行修改</li>
<li>node_modules/@vue/cli-service/webpack.config.js，进去你会发现一个require(‘./lib/Service’)你会发现各种各样的配置</li>
<li>vue.config.js：在你当前这个项目的目录下创建这个文件，名字是固定的，在build时会进行合并</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><ul>
<li>如果箭头函数中只有一行代码，那么它会自动把这行代码返回</li>
<li>箭头函数中this与正常的function定义不同</li>
</ul>
</li>
</ul>
<h3 id="10-Vue-router"><a href="#10-Vue-router" class="headerlink" title="10. Vue-router"></a>10. Vue-router</h3><ul>
<li><h5 id="SPA页面（单页面富应用，-simple-page-web-application，前端路由阶段）"><a href="#SPA页面（单页面富应用，-simple-page-web-application，前端路由阶段）" class="headerlink" title="SPA页面（单页面富应用， simple page web application，前端路由阶段）"></a>SPA页面（单页面富应用， simple page web application，前端路由阶段）</h5><ul>
<li>核心为:改变url整体页面不刷新</li>
</ul>
</li>
<li><h5 id="如何实现改变url，页面不刷新"><a href="#如何实现改变url，页面不刷新" class="headerlink" title="如何实现改变url，页面不刷新"></a>如何实现改变url，页面不刷新</h5><ul>
<li><p>更改url的hash，例如：</p>
<pre><code>www.baidu.com
console:  location.hash = &apos;aaa&apos;
result: www.baidu.com/aaa，但是页面不会刷新</code></pre></li>
<li><p>H5里边的history模式:</p>
<ul>
<li>history.pushState({}, ‘’, ‘aaa’)<br>history.back()<br>history.forward()<br>这两个可以配套，可以返回<br>history.go()  注：history.go(-1) == history.back(),history.go(1) == history.forward()</li>
<li>history.replaceState({}, ‘’, ‘bbb’)  这个不能返回</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h5><ul>
<li><p>to属性： 定义要指向的url</p>
<pre><code>&lt;router-link to=&apos;/home&apos;&gt;&lt;/router-link&gt;</code></pre></li>
<li><p>tag: router-link最终默认渲染成a标签，我们可以手动改为别的</p>
<pre><code>&lt;router-link tag=&apos;div&apos; or tag=&apos;button&apos;&gt;&lt;/router-link&gt;</code></pre></li>
<li><p>router-link当使用h5的history时，默认使用pushState(可以使用网页中的后撤键)，我们可以手动设置成replaceState(禁止用户使用后撤键)</p>
<pre><code>&lt;router-link to=&apos;/home&apos; tag=&apos;li&apos; replace&gt;&lt;/router-link&gt;</code></pre></li>
<li><p>active-class:两个roter处于活跃状态时，添加的class(很少用)</p>
<pre><code>&lt;router-link to=&apos;/home&apos; tag=&apos;li&apos; replace active-class=&apos;myClass&apos;&gt;&lt;/router-link&gt;</code></pre></li>
<li><p>在组件当中使用时，是使用$router属性进行修改</p>
<pre><code>this.$router.push(&apos;/home&apos;)</code></pre></li>
<li><p>动态路由的使用：例如，要在home页面后边动态的拼接url，就需要在映射里边进行修改</p>
<pre><code>routes: [
    {
        path: &apos;/home/:userId&apos;       //这个userId可以为任意名字
        component： Home
    }
]</code></pre><p>  然后在调用的时候用v-bind进行绑定就行</p>
<pre><code>&lt;router-link :to=&quot;&apos;/home&apos; + 我们data里边的数据名称&quot;&gt;&lt;/router-link&gt;</code></pre><p>  我们如何获取home后边的数据，并使用到我们的vue当中：使用this.$route</p>
<pre><code>可以在methods或者computed里边
this.$route.params.userId         //这里为什么是userId，是因为上边我们写的名字为userId，加入是abc，这里就是abc</code></pre><p>  this.$router和this.$route的区别：</p>
<pre><code>+ this.$router:是我们在router.js里边我们const rou = new Router({})的常量
+ this.$route是当前我们在使用哪个路由，也就是哪个路由处于活跃状态</code></pre></li>
</ul>
</li>
<li><h5 id="路由的懒加载"><a href="#路由的懒加载" class="headerlink" title="路由的懒加载"></a>路由的懒加载</h5><ul>
<li><p>vueCLI3，经过npm run build打包之后的js文件分为三个：</p>
<ul>
<li>app.哈希码.js：业务逻辑代码，也就是我们自己写的代码</li>
<li>manifest.哈希码.js：底层的支撑，比如说对ES6，CommonJS的支撑等</li>
<li>vendor.哈希码.js：项目里边引用的第三方的东西，例如vue和vue-router等</li>
</ul>
</li>
<li><p>为什么使用懒加载</p>
<ul>
<li>项目在打包时，js文件可能会非常大，同时加载可能会影响加载速度，所以需要懒加载（用到时再加载）</li>
<li>如果把不同的路由对应的组件分割成不同的代码块，当路由被访问时再加载对应的组件，效率就更好了（也就是用到时再加载）</li>
<li>懒加载做的事情就是将路由对应的组件包装成一个又一个的小的js文件，用到时再加载</li>
</ul>
</li>
<li><p>代码实现：</p>
<pre><code>原来是：
import Home from &apos;./components/home&apos;
routes: [
    {
        path: &apos;/home&apos;
        component： Home
    }
]

懒加载：
routes: [
    {
        path: &apos;/home&apos;
        component： () =&gt; import(&apos;./components/home&apos;)
    }
]
或者(这样写的话更简洁，方便统一管理)：
const Home = () =&gt; import(&apos;./components/home&apos;)
routes: [
    {
        path: &apos;/home&apos;
        component： Home
    }
]</code></pre></li>
</ul>
</li>
<li><h5 id="路由的嵌套："><a href="#路由的嵌套：" class="headerlink" title="路由的嵌套："></a>路由的嵌套：</h5><ul>
<li><p>假如我们想在/home后边添加子路由/news，需要这样配置(子路由里边也可以设置默认值，设置redirect)：</p>
<pre><code>routes: [
    {
        path: &apos;/home&apos;
        component： () =&gt; import(&apos;./components/home&apos;)
        children: [
            {
                path: &apos;news&apos;        //注意，这里不需要加/
                component: import(&apos;./components/news&apos;)
            },
        ]
    }
]</code></pre><p>  然后需要到Home组件当中再添加一个router-view，并且router-link也要注意写全，而不是只写news</p>
<pre><code>&lt;router-link to=&apos;/home/news&apos;&gt;&lt;/router-link&gt;
&lt;router-view&gt;&lt;/router-view&gt;</code></pre></li>
</ul>
</li>
<li><h5 id="路由的参数传递"><a href="#路由的参数传递" class="headerlink" title="路由的参数传递"></a>路由的参数传递</h5><ul>
<li><p>第一种方式就是上边的动态路由</p>
</li>
<li><p>query方式</p>
<ul>
<li><p>要更改router-link中的to属性，用v-bind绑定，然后绑定一个{}对象，里边有path和query属性</p>
<pre><code>&lt;router-link :to=&quot;{path: &apos;/user&apos;, query:{name:&apos;lalala&apos;, age: 18}}&quot;&gt;&lt;/router-link&gt;</code></pre><p>  然后在user.vue里边使用$route.query.age等来取出来进行使用</p>
</li>
</ul>
</li>
<li><p>在组件的methods中使用，也是使用this.$router.push()，然后在push里边输入上边的对象即可</p>
<p>  methods: {</p>
<pre><code>这是我的方法名() {
    return this.$router.push({
        path: &apos;/user&apos;, 
        query: {
            name:&apos;lalala&apos;, 
            age: 18 
        }
    })
}</code></pre><p>  }</p>
</li>
</ul>
</li>
<li><h5 id="导航守卫（去看看vue-router的官网）"><a href="#导航守卫（去看看vue-router的官网）" class="headerlink" title="导航守卫（去看看vue-router的官网）"></a>导航守卫（去看看vue-router的官网）</h5></li>
<li><h5 id="keep-alive及其他问题"><a href="#keep-alive及其他问题" class="headerlink" title="keep-alive及其他问题"></a>keep-alive及其他问题</h5><ul>
<li>vue组件除了created和beforeMouted等属性，还有activated和deactivated属性，不过这两个属性只有在组件被keep-alive包起来时才能使用</li>
<li>它有两个非常重要的属性：<ul>
<li>include：字符串或正则表达式，只有匹配的组件会被缓存</li>
<li>exclude：字符串或正则表达式，任何匹配的组件都不会被缓存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="11-符号的解释，例如-router"><a href="#11-符号的解释，例如-router" class="headerlink" title="11. $符号的解释，例如$router"></a>11. $符号的解释，例如$router</h3><ul>
<li><p><strong>所有的vue组件都继承自vue类的原型</strong></p>
<ul>
<li><p>例如，当你给vue类的原型，添加一个属性时，那么所有的组件都可以使用这个属性</p>
<pre><code>Vue.prototype.test = function(){
    console.log(&apos;这是测试&apos;)
} </code></pre><p>  那么你在任意的组件里边都可以使用this.test()进行调用，一般来说都使用$test来防止冲突</p>
</li>
</ul>
</li>
</ul>
<h3 id="12-Promise"><a href="#12-Promise" class="headerlink" title="12. Promise"></a>12. Promise</h3><ul>
<li><h5 id="Promise的基本使用："><a href="#Promise的基本使用：" class="headerlink" title="Promise的基本使用："></a>Promise的基本使用：</h5><ul>
<li><p>什么情况下会用到promise？</p>
<ul>
<li>一般情况下，是有异步操作时，使用promise对异步操作进行封装</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>Promise接收的参数是一个函数</li>
<li>resolve和reject都是函数</li>
<li>then和catch接收的也都是函数</li>
</ul>
</li>
<li><p>链式调用使用方式：</p>
<pre><code>new Promise((resolve, reject) =&gt; {
    setTimeout((data) =&gt; {      //这里用setTimeout来模拟异步操作
        resolve(data)           //用resolve函数来把data传给then函数
        reject(&apos;error data&apos;)    //数据获取失败，使用reject
    }, 1000)
}).then(data =&gt; {               //当数据获取成功时，使用resolve函数，然后执行then函数
    console.log(data)
    return new Promise((resolve, reject) =&gt; {
        //来这里进行嵌套调用
    })
}).catch(data =&gt; {
    console.log(data)       //这里打印的就是error data这个字符串
}) </code></pre></li>
</ul>
</li>
<li><h5 id="Promise的链式调用"><a href="#Promise的链式调用" class="headerlink" title="Promise的链式调用"></a>Promise的链式调用</h5><ul>
<li><p>简化过程：</p>
<pre><code>new Promise((resolve, reject) =&gt; {
    setTimeout((data) =&gt; {      
        resolve(data)           
        reject(&apos;error data&apos;)   
    }, 1000)
}).then(data =&gt; {               
    console.log(data)       //拿到data后，想对data进行操作，比如拼接&apos;111&apos;
    return new Promise((resolve, reject) =&gt; {       //这里的reject没用到，所以可以省略，写成resolve =&gt; {}
        resolve(data + &apos;111&apos;)
    })
}).then(res =&gt; {
    console.log(res)
})</code></pre></li>
<li><p>上边的过程进行简化(Promise提供了resolve方法，当然也有reject方法，可以在catch里边使用)</p>
<pre><code>new Promise((resolve, reject) =&gt; {
    setTimeout((data) =&gt; {      
        resolve(data)           
        reject(&apos;error data&apos;)   
    }, 1000)
}).then(data =&gt; {               
    console.log(data)       
    return Promise.resolve(data + &apos;111&apos;)
}).then(res =&gt; {
    console.log(res)
})</code></pre></li>
<li><p>再次简化(Promise自动对返回的数据使用Promise.resolve进行封装，reject不行)</p>
<pre><code>new Promise((resolve, reject) =&gt; {
    setTimeout((data) =&gt; {      
        resolve(data)           
        reject(&apos;error data&apos;)   
    }, 1000)
}).then(data =&gt; {               
    console.log(data)       
    return data + &apos;111&apos;
}).then(res =&gt; {
    console.log(res)
})</code></pre></li>
</ul>
</li>
</ul>
<h3 id="13-axios"><a href="#13-axios" class="headerlink" title="13. axios"></a>13. axios</h3><ul>
<li><h5 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h5><ul>
<li><p>axios(config)</p>
<pre><code>axios({
    url:
    params:
    method:
    timeout:
    ...
})</code></pre></li>
<li><p>axios.get()</p>
</li>
<li><p>axios.post()</p>
</li>
<li><p>axios.delete()</p>
</li>
<li><p>axios.head()</p>
</li>
<li><p>axios.put()</p>
</li>
<li><p>axios.patch()</p>
</li>
</ul>
</li>
<li><h5 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h5><ul>
<li><p>做一个功能，需要两个请求都到达后，才向下进行</p>
</li>
<li><p>axios.all(list)：</p>
<ul>
<li><p>参数：需要传入一个数组，需要几个同时到达，就在数组里边写几个数据请求</p>
</li>
<li><p>返回：一个数组</p>
<pre><code>axios.all([axios(), axios()]).then(res =&gt; {
    res[0].操作
    res[1].操作
})</code></pre><p>  还有一个方法axios.spread可以将结果展开</p>
<pre><code>axios.all([axios(), axios()])
.then(axios.spread((res1, res2) =&gt; {
    res1.操作
    res2.操作
}))</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><h5 id="关于配置config的相关信息"><a href="#关于配置config的相关信息" class="headerlink" title="关于配置config的相关信息"></a>关于配置config的相关信息</h5><ul>
<li>axios.default.baseURL巴拉巴拉的</li>
<li>baseURL</li>
<li>timeout</li>
<li>method</li>
<li>transformRequest</li>
<li>transformResponse</li>
<li>headers</li>
<li>params</li>
</ul>
</li>
<li><h5 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h5><ul>
<li><p>为了防止总是使用全局的axios产生混乱，或者处理不同请求的不同配置，需要为请求创建实例</p>
</li>
<li><p>axios.create(config)</p>
<pre><code>const instance1 = axios.create({
                        baseURL:
                        timeout:
                    })
instance1({
    url: &quot;&quot;
}).then(res =&gt; {}).catch(err =&gt; {}) //catch捕捉异常</code></pre></li>
</ul>
</li>
<li><h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5><ul>
<li><p>用于我们发送请求后，或者得到响应后，进行对应的处理</p>
</li>
<li><p>请求拦截:例如有一个instance1实例，那么拦截器代码为：</p>
<ul>
<li><p>instance1.interceptors.request.use(config =&gt; {}, err =&gt; {}) 拦截请求</p>
</li>
<li><p>use()代表你要使用这个拦截器，他有两个参数，两个参数都为函数</p>
<ul>
<li>config:请求成功时使用的函数</li>
<li>err: 请求失败时的函数</li>
</ul>
</li>
<li><p>使用：</p>
<pre><code>instance1.interceptors.request.use(config =&gt; {
    console.log(config)
    return config   // **当你使用拦截器时，一定要返回，否则就被拦截掉了，无法请求到数据**
}, err =&gt; {})</code></pre></li>
<li><p>请求拦截的作用：</p>
<ul>
<li>比如我们在请求中，想添加那个圆圈动画，可以在config中添加，</li>
<li>或者对config进行规范，这就是拦截器的作用</li>
<li><strong>比如我们请求数据时，需要携带token，比如需要用户先登录，就可以先拦截下来，然后跳转到用户登录界面，进行登录，再继续请求数据</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>响应拦截：</p>
<ul>
<li><p>instance1.interceptors.response 拦截响应</p>
</li>
<li><p>使用：</p>
<pre><code>instance1.interceptors.response().use(res =&gt; {
    一系列处理。。。。
    return res //记得返回，否则请求的地方就拿不到结果
    或者：
    return res.data //只返回data，这样可以去掉服务器给我们的其他的乱七八糟的东西
}, err =&gt; {})</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="14-Vuex"><a href="#14-Vuex" class="headerlink" title="14. Vuex"></a>14. Vuex</h3><ul>
<li><h5 id="Vuex简介"><a href="#Vuex简介" class="headerlink" title="Vuex简介"></a>Vuex简介</h5><ul>
<li>什么是Vuex？<ul>
<li>Vuex是专为Vus.js开发的一个状态管理模式</li>
<li>所谓状态管理模式就是，有很多个组件需要共享多个变量，那么把这多个变量放到一个对象里边，然后把这个对象放到vue的顶层的示例里边，给所有组件共享（我们也可以自己写，但是Vuex是响应式的，自己实现比较麻烦）。</li>
<li><strong>Vuex里边储存的一定是需要在多个页面共享的状态</strong></li>
</ul>
</li>
<li>什么样的状态需要在多个组件之间共享，而不是使用父子组件传讯的方式？（token）<ul>
<li>大型项目里边的状态，比如说：用户的登陆状态、地理位置信息、购物车状态等，这些状态就需要统一的地方保存和管理，并且还是响应式的</li>
<li>token：在后台请求数据时，需要携带token（令牌）</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="Vuex的使用"><a href="#Vuex的使用" class="headerlink" title="Vuex的使用"></a>Vuex的使用</h5><ul>
<li><p>创建过程(真正创建的不是new Vuex而是 new Vuex.Store)：</p>
<pre><code>import Vue from &apos;vue&apos;
import Vuex from &apos;vuex&apos;

Vue.use(Vuex)

const store = new Vuex.Store({
    state:{},       //存储数据状态
    mutations:{},   //定义方法，
    actions:{},     //用来处理异步操作
    getters:{},     //类似于组件里边的计算属性
    modules:{}      //划分模块，针对不同的模块再进行管理
})

export default store</code></pre><p>  &lt;然后再main class=”js里边导入并注册”&gt;&lt;/然后再main&gt;</p>
</li>
<li><p>state的修改过程：</p>
<ul>
<li>Vue components -(dispathc)-&gt; Actions -(commit)-&gt; Mutations -(mutate)-&gt; State -(Render)-&gt; Vue components 或者<br>Vue components –&gt; Mutations –&gt; State –&gt; Vue components</li>
<li>Actions:它的作用是用来处理异步操作，异步网络请求，因为为了追踪State是在哪里被修改了，官方给Mutations开发了一个Chrome插件Devtools，而这个插件只能监听同步操作，无法监听异步，所以才需要Actions</li>
</ul>
</li>
<li><p>核心模块详解：</p>
<ul>
<li><p>state：保存状态，推荐使用单一状态树，即只创建一个store</p>
<ul>
<li>单一状态树：就是建议在store.js里边只有一个new store</li>
</ul>
</li>
<li><p>getters：类似于组件里边的计算属性computed，它也有默认的state参数，还可以有另外一个参数就是getters，也就是这个getters本身，用来获取getters里边的方法，例如sum(state, getters)，<strong>也就是说，不管你前两个参数叫什么名字，第一个参数代表的一定是state，第二个一定是getters</strong>，所以说如果想给getters传参，要使用其他方法：</p>
<pre><code>getters: {
    sum(state) {
        return function(这是我想传入的参数){
            //在这里使用参数即可
        }
    }
}</code></pre><p>  因为返回的是个函数，所以在调用的时候以函数的形式使用，并传入参数即可</p>
<pre><code>this.$store.getters.sum(我是参数)</code></pre></li>
<li><p>mutations：这里边的方法会有一个默认参数为state，也就是上边这个state，比如说定义sum(),它相当于sun(state)</p>
<ul>
<li><p>使用mutations里边定义的函数的方法：</p>
<pre><code>store.commit(&apos;mutations里边定义的方法名&apos;)
components里边为this.$store.commit(&apos;sum&apos;)</code></pre></li>
<li><p>传参方式：</p>
<pre><code>首先：
sum (state, num){           //在这里定义并使用
    sum += num
}
store.commit(&apos;sum&apos;, count)  //先这里进行传参</code></pre></li>
<li><p>另外一种提交方式：</p>
<pre><code>store.commit({
    type: &apos;sum&apos;,
    count: count
})</code></pre><p>  使用这种方式的时候就要注意，传过去的参数，不是一个数值，而是一个对象，在函数里边使用时，要用num.count才可以    </p>
</li>
<li><p>类型常量（去看一眼视频吧，理解了下边挺简单的，或者看官网)：就是单独创建了一个文件，在里边定义函数名并导出，然后后按照第二种方法的声明方式，在mutations里边和使用的地方进行统一，例如</p>
<pre><code>export const MYPARAM = &apos;myparam&apos;
import {MYPARAM} from &apos;xx.js&apos;
原来函数定义为：
myparam(){

}
因为可以定义为
[&apos;myparam&apos;](){

}
所以现在可以为：
[MYPARAN](){

}</code></pre><p>  这样的话，在使用的时候，方法名得到了统一，哪怕我在export const MYPARAM = ‘myparam’写错了，对我的代码也没有影响，这是官方推荐形式</p>
<ul>
<li><p>方法的定义不光可以使用：</p>
<pre><code>方法名(){

}</code></pre><p>  也可以使用</p>
<pre><code>[&apos;方法名&apos;](){

}</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>action：因为Devtool不能监听异步操作，所以所有异步操作都要在action里边进行</p>
<pre><code>函数声明和mutations一样，只不过默认参数不一样：
sum(context, param){        //这里的param是用来接收参数，没有传参可以不写，这里的context可以看成我们声明的store，也就是$store
    setTimeout(() =&gt; {
        //这里调用mutations里边的函数！注意这里不能跳过mutations直接操作state
        context.state.myData = &apos;lalalal&apos;    //直接修改了所以是错误的
        context.commit(&apos;mutations里边的方法&apos;)    //正确写法
    }, 1000)
}</code></pre><p>  在使用时，应该是</p>
<pre><code>this.$store.dispatch(&apos;sum&apos;, &apos;这第二个参数，是我要传递的参数，可以不写&apos;)</code></pre><ul>
<li><p>如何判断里边的异步函数已经完成，可以从action里边传回一个Promise(可以看看视频，我觉得天秀)：</p>
<pre><code>sum(context, myParam){
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            context.commit(&apos;mutations里边的方法&apos;)
            console.log(myParam)

            resolve(&apos;这是我想传回去的参数&apos;)       
        }, 1000)    //神奇的地方来了，不在这里写then，而是在调用的地方
    })
}

this.$store.dispatch(&apos;sum&apos;, &apos;这是参数&apos;).then(res =&gt; {
    console.log(&apos;里边的异步已经执行完了&apos;)
    console.log(res)    //这是resolve给的数据
})</code></pre><p>  <strong>解释</strong>：因为then函数是接在new Promise后边的，而sum函数return的就是一个new Promise，所以我们的this.$store.dispatch(‘sum’, ‘这是参数’)这句代码执行完之后，相当于被替换成了new Promise()，所以它后边可以接then（天秀！！！）</p>
</li>
</ul>
</li>
<li><p>modules：当你想要进行模块划分时，在这里边进行，举例：</p>
<pre><code>const moduleC = {
    state:{},
    mutations:{},
    actions:{},
    getters:{},
    modules:{}
}

modules: {
    a: {
        state:{},
        mutations:{},
        actions:{},
        getters:{},
        modules:{}
    },
    b: {
        state:{},
        mutations:{},
        actions:{},
        getters:{},
        modules:{}
    },
    c: moduleC
}</code></pre><p>  这样来进行你想要的划分，使用方法：</p>
<ul>
<li><p>state：modules里边的state在使用时，Vue是将它封装成一个对象，放在根state里边的，所以使用是： $store.state.a.name</p>
</li>
<li><p>mutations：modules里边的mutations的命名不能与根store里边的命名重复，因为它的使用是：$store.commit(‘modules里边的mutations的方法名’)，直接调用，如果重复了会有冲突</p>
</li>
<li><p>getters：modules里边的getters，可以直接调用自己本模块的getters，也可以直接调用根模块的getters</p>
</li>
<li><p>actions：与根模块相比，他的context多了两个属性：rootGetters和rootState</p>
</li>
<li><p>对象的解构：</p>
<pre><code>const obj = {
    name: &apos;123&apos;,
    age: 19,
    height:1.88
}

解构的使用办法为：
const {name, height, age} = obj     //它是按名字取值的，不是按顺序</code></pre></li>
</ul>
</li>
<li><p>目录结构：</p>
<ul>
<li>将mutations和actions等，抽成单个的文件，然后再store.js里边导入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><h5 id="Vuex的数据响应式"><a href="#Vuex的数据响应式" class="headerlink" title="Vuex的数据响应式"></a>Vuex的数据响应式</h5><ul>
<li><p>什么样的数据是响应式</p>
<ul>
<li><p><strong>必须是提前在store中初始化好的属性</strong>，也就是说我们后边通过一些方法添加的属性，不是响应式的，例如:</p>
<pre><code>store.state.info[&apos;address&apos;] = &apos;lalala&apos;      //address是我们新添加的属性</code></pre></li>
<li><p>我们可以使用Vue的方法来使我们添加的数据变为响应式</p>
<ul>
<li>Vue.set(要更改的数据, 下标或属性, value)     //当要改的数据为数组时，第二个参数为下标</li>
<li>Vue.delete(要更改的数据, 下标或属性)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </section>
        <hr/>
        <nav class="pagination" style="width:auto" role="pagination">
            
            <a data-pjax class="newer-posts" href="/2020/12/01/Typescript/">← Prev Post</a>
            
            <a class="share-button" data-original-title title>Share this Post</a>
            
            <a data-pjax class="older-posts" href="/2020/02/17/V开场台词/">Next Post →</a>
            
        </nav>
        <br/>
        <br/>
        <section id="comment">
            <div id="comment-box"></div>
        </section>


    </article>
</main>


  
<footer class="site-footer">
    
    <div class="inner">
        <section class="copyright"><a href="/"></a> &copy; Lightman's blog 2014</section>
        <section class="poweredby">Published with <a target="_blank" href="http://hexo.io/">Hexo   </a> and Theme by <a target="_blank" href="https://github.com/yuche/hexo-theme-kael">Kael</a></section>
    </div>
</footer>
</div>
</div><!-- /scroller -->

</div><!-- /pusher -->
</div><!-- /container -->
</div>

<!-- Easter eggs -->

<div class="egg animated">
    <a id="close-button" href="#">X</a>
    <div class="block">
        <div class="loading">
            <span class="ball1"></span>
            <span class="ball2"></span>
        </div>
    </div>
</div>
  
<script src="//cdn.staticfile.org/jquery/1.11.0/jquery.min.js"></script>
<script>
    if (!window.jQuery) {
        var script = document.createElement('script');
        script.src = "/js/jquery.min.js";
        document.body.appendChild(script);
    }
</script>
<script type="text/javascript" src="/js/lib.js"></script>
<script type="text/javascript" src="/js/main.js"></script>







</body>
</html>
