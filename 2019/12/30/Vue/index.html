<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Vue | Lightman&#39;s blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="Vue | Lightman&#39;s blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="台词   V: I can assure you,I mean you no harm   女主: Who are you?   V: Who?Who is but the form following the function of what and what I am is a man in a mask   女主: Oh,I can see that   V: Of course you">
<meta property="og:type" content="article">
<meta property="og:title" content="V 开场自我介绍">
<meta property="og:url" content="http://yoursite.com/2020/02/17/V%E5%BC%80%E5%9C%BA%E5%8F%B0%E8%AF%8D/index.html">
<meta property="og:site_name" content="Lightman&#39;s blog">
<meta property="og:description" content="台词   V: I can assure you,I mean you no harm   女主: Who are you?   V: Who?Who is but the form following the function of what and what I am is a man in a mask   女主: Oh,I can see that   V: Of course you">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-17T06:20:11.000Z">
<meta property="article:modified_time" content="2020-02-17T06:21:59.631Z">
<meta property="article:author" content="Lightman">
<meta property="article:tag" content="电影台词">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>Lightman</span>
</div>

<div class="icon">
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(18)</small></div></li>
    
        
            
            <li><div data-rel="深度学习">深度学习<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="英语">英语<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="前端技术">前端技术<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="常用技术">常用技术<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="强化学习">强化学习<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="后台技术">后台技术<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法">算法<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="读书笔记">读书笔记<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="18">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color2">AutoEncoder</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">连读发音</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Flex</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">CNN</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">GAN</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">JavaScript</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">协作开发软件</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">LSTM</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">Q网络</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">GCN</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">Ted</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">Python</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">算法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">沉默的大多数</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">电影台词</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="深度学习 "
           href="/2019/12/23/AdvancedAutoEncoder/"
           data-tag="AutoEncoder"
           data-author="" >
            <span class="post-title" title="AdvancedAutoEncoder">AdvancedAutoEncoder</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="英语 "
           href="/2019/12/23/EnglishPronunciation/"
           data-tag="连读发音"
           data-author="" >
            <span class="post-title" title="连读规则">连读规则</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="前端技术 "
           href="/2019/01/23/Flex/"
           data-tag="Flex"
           data-author="" >
            <span class="post-title" title="Flex 布局">Flex 布局</span>
            <span class="post-date" title="2019-01-23 00:12:21">2019/01/23</span>
        </a>
        
        <a  class="深度学习 "
           href="/2019/12/23/CNN/"
           data-tag="CNN"
           data-author="" >
            <span class="post-title" title="卷积神经网络">卷积神经网络</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="深度学习 "
           href="/2019/12/23/AutoEncoder/"
           data-tag="AutoEncoder"
           data-author="" >
            <span class="post-title" title="AutoEncoder">AutoEncoder</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="深度学习 "
           href="/2019/12/23/GAN/"
           data-tag="GAN"
           data-author="" >
            <span class="post-title" title="GAN网络代码">GAN网络代码</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="前端技术 "
           href="/2019/12/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"
           data-tag="JavaScript"
           data-author="" >
            <span class="post-title" title="JavaScript 高级程序设计">JavaScript 高级程序设计</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="常用技术 "
           href="/2019/12/23/Git/"
           data-tag="协作开发软件"
           data-author="" >
            <span class="post-title" title="Git教程">Git教程</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="深度学习 "
           href="/2019/12/23/LSTM/"
           data-tag="LSTM"
           data-author="" >
            <span class="post-title" title="LSTM简介及代码">LSTM简介及代码</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="深度学习 "
           href="/2019/12/23/CNNAutoEncoder/"
           data-tag="AutoEncoder,CNN"
           data-author="" >
            <span class="post-title" title="卷积自编码器">卷积自编码器</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="强化学习 "
           href="/2019/12/23/ReinforcementLearning/"
           data-tag="Q网络"
           data-author="" >
            <span class="post-title" title="强化学习简介">强化学习简介</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="深度学习 "
           href="/2019/12/23/STGCN/"
           data-tag="GCN"
           data-author="" >
            <span class="post-title" title="时空图卷积网络">时空图卷积网络</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="英语 "
           href="/2019/12/23/Ted_%E7%BB%99%E9%99%8C%E7%94%9F%E4%BA%BA%E7%9A%84%E6%83%85%E4%B9%A6/"
           data-tag="Ted"
           data-author="" >
            <span class="post-title" title="汉娜·布伦雪尔：给陌生人的情书">汉娜·布伦雪尔：给陌生人的情书</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class=""
           href="/2019/12/30/Vue/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Vue">Vue</span>
            <span class="post-date" title="2019-12-30 23:41:25">2019/12/30</span>
        </a>
        
        <a  class="后台技术 "
           href="/2019/12/23/python/"
           data-tag="Python"
           data-author="" >
            <span class="post-title" title="Python教程">Python教程</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="算法 "
           href="/2019/12/23/%E7%AE%97%E6%B3%95/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法速查">算法速查</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="读书笔记 "
           href="/2019/12/23/%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0/"
           data-tag="沉默的大多数"
           data-author="" >
            <span class="post-title" title="沉默的大多数">沉默的大多数</span>
            <span class="post-date" title="2019-12-23 00:12:21">2019/12/23</span>
        </a>
        
        <a  class="英语 "
           href="/2020/02/17/V%E5%BC%80%E5%9C%BA%E5%8F%B0%E8%AF%8D/"
           data-tag="电影台词"
           data-author="" >
            <span class="post-title" title="V 开场自我介绍">V 开场自我介绍</span>
            <span class="post-date" title="2020-02-17 14:20:11">2020/02/17</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-Vue" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Vue</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-01-30 22:48:28'>2019-12-30 23:41</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意"><span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6语法"><span class="toc-text">ES6语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-计算属性"><span class="toc-text">1. 计算属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JavaScript高阶函数"><span class="toc-text">2. JavaScript高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#回调函数："><span class="toc-text">回调函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#obj-filter-callbackfn"><span class="toc-text">obj.filter(callbackfn)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#obj-map"><span class="toc-text">obj.map()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#obj-reduce"><span class="toc-text">obj.reduce()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-v-model"><span class="toc-text">3. v-model</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#修饰符"><span class="toc-text">修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-组件化"><span class="toc-text">4. 组件化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#什么是组件化？"><span class="toc-text">什么是组件化？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vue的组件化思想"><span class="toc-text">Vue的组件化思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#全局组件与局部组件"><span class="toc-text">全局组件与局部组件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组件之间传值"><span class="toc-text">#组件之间传值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-父子组件间的访问方式"><span class="toc-text">5. 父子组件间的访问方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#父组件访问子组件"><span class="toc-text">父组件访问子组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#子组件访问父组件"><span class="toc-text">子组件访问父组件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-插槽"><span class="toc-text">6. 插槽</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#slot基本使用"><span class="toc-text">slot基本使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#具名插槽slot"><span class="toc-text">具名插槽slot</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#作用域插槽slot"><span class="toc-text">作用域插槽slot</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-模块化开发"><span class="toc-text">7. 模块化开发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ES5模块化"><span class="toc-text">ES5模块化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#常见的模块化规范"><span class="toc-text">常见的模块化规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ES6的模块化"><span class="toc-text">ES6的模块化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Webpack"><span class="toc-text">8. Webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#基本使用"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#核心为loader，可以在官方文档里边查找使用方法，用来处理各个文件，进行打包"><span class="toc-text">核心为loader，可以在官方文档里边查找使用方法，用来处理各个文件，进行打包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#plugin-在js文件里添加版权信息，webpack-BannerPlugin"><span class="toc-text">plugin 在js文件里添加版权信息，webpack.BannerPlugin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HtmlWebpackPlugin-插件"><span class="toc-text">HtmlWebpackPlugin 插件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#webpack-dev-server搭建本地服务器"><span class="toc-text">webpack-dev-server搭建本地服务器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#给文件夹起别名"><span class="toc-text">给文件夹起别名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Vue-CLI"><span class="toc-text">9. Vue CLI</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#安装"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vue-CLI2初始化项目"><span class="toc-text">Vue CLI2初始化项目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vue-CLI3初始化项目"><span class="toc-text">Vue CLI3初始化项目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Vue-router"><span class="toc-text">10. Vue-router</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SPA页面（单页面富应用，-simple-page-web-application，前端路由阶段）"><span class="toc-text">SPA页面（单页面富应用， simple page web application，前端路由阶段）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#如何实现改变url，页面不刷新"><span class="toc-text">如何实现改变url，页面不刷新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#router-link"><span class="toc-text">router-link</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#路由的懒加载"><span class="toc-text">路由的懒加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#路由的嵌套："><span class="toc-text">路由的嵌套：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#路由的参数传递"><span class="toc-text">路由的参数传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#导航守卫（去看看vue-router的官网）"><span class="toc-text">导航守卫（去看看vue-router的官网）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#keep-alive及其他问题"><span class="toc-text">keep-alive及其他问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-符号的解释，例如-router"><span class="toc-text">11. $符号的解释，例如$router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Promise"><span class="toc-text">12. Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise的基本使用："><span class="toc-text">Promise的基本使用：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise的链式调用"><span class="toc-text">Promise的链式调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-axios"><span class="toc-text">13. axios</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法简介"><span class="toc-text">方法简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#并发请求"><span class="toc-text">并发请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#关于配置config的相关信息"><span class="toc-text">关于配置config的相关信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#创建实例"><span class="toc-text">创建实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#拦截器"><span class="toc-text">拦截器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Vuex"><span class="toc-text">14. Vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Vuex简介"><span class="toc-text">Vuex简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vuex的使用"><span class="toc-text">Vuex的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vuex的数据响应式"><span class="toc-text">Vuex的数据响应式</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><ol>
<li>DOM里边使用定义的别名，需要在前边加上“~”</li>
<li>this.$router 拿到的是vue-router这个对象，this.$route 拿到的是当前哪个路由处于活跃状态</li>
</ol>
<h3 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a><strong>ES6语法</strong></h3><ul>
<li>ES6除了’’和””以外，还可以使用``（TAB上边的那个点）来定义字符串，他的好处是可以直接回车换行</li>
</ul>
<h3 id="1-计算属性"><a href="#1-计算属性" class="headerlink" title="1. 计算属性"></a>1. 计算属性</h3><ul>
<li>计算属性(computed)本质上是一个属性，它有getter和setter，但是我们在使用时只是实现了getter，而没有实现setter</li>
<li>计算属性在使用多次时，只会调用1次（因为他是有缓存的，效率比methods要高）</li>
<li>v-show与v-if的区别：v-show是修改diplay属性，而v-if是dom是否渲染，是否存在</li>
</ul>
<h3 id="2-JavaScript高阶函数"><a href="#2-JavaScript高阶函数" class="headerlink" title="2. JavaScript高阶函数"></a>2. JavaScript高阶函数</h3><ul>
<li><h5 id="回调函数："><a href="#回调函数：" class="headerlink" title="回调函数："></a>回调函数：</h5><ul>
<li>被用于高级函数里边，作为参数传给高级函数的函数就称为回调函数。</li>
<li>还有一种说法是，用来规范js函数的调用顺序。</li>
</ul>
</li>
<li><h5 id="obj-filter-callbackfn"><a href="#obj-filter-callbackfn" class="headerlink" title="obj.filter(callbackfn)"></a>obj.filter(callbackfn)</h5><ul>
<li>参数为回调函数，对obj执行callbackfn进行过滤</li>
</ul>
</li>
<li><h5 id="obj-map"><a href="#obj-map" class="headerlink" title="obj.map()"></a>obj.map()</h5><ul>
<li>对obj进行操作</li>
</ul>
</li>
<li><h5 id="obj-reduce"><a href="#obj-reduce" class="headerlink" title="obj.reduce()"></a>obj.reduce()</h5><ul>
<li>对obj进行汇总</li>
</ul>
</li>
</ul>
<h3 id="3-v-model"><a href="#3-v-model" class="headerlink" title="3. v-model"></a>3. v-model</h3><ul>
<li>label要想互斥（只能2选1），要给label里边的input的name属性赋相同的值</li>
<li>在vue里边，如果给label里边的input的value属性绑定相同的data也可以互斥</li>
<li><strong>v-model本质为，v-bind:value + v-on:input=”data = $event.target.value”</strong></li>
<li>v-model绑定checkbox，绑定单个值，data为boolean类型。绑定多个值时，只需要给data设置为[](list类型)即可</li>
<li><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><ul>
<li>lazy：v-model是实时绑定的，当使用v-model.lazy时，可以实现用户敲回车或者点击空白（失去焦点）的时候再进行刷新绑定</li>
<li>number：v-model进行值绑定时，默认为string类型，这时候使用v-model.number</li>
<li>trim：v-model去掉多余的空格</li>
</ul>
</li>
</ul>
<h3 id="4-组件化"><a href="#4-组件化" class="headerlink" title="4. 组件化"></a>4. 组件化</h3><ul>
<li><h5 id="什么是组件化？"><a href="#什么是组件化？" class="headerlink" title="什么是组件化？"></a>什么是组件化？</h5><ul>
<li>将大的问题拆成一个又一个小的问题去解决</li>
</ul>
</li>
<li><h5 id="Vue的组件化思想"><a href="#Vue的组件化思想" class="headerlink" title="Vue的组件化思想"></a>Vue的组件化思想</h5><ul>
<li>可以让我们用一个又一个独立可复用的小组件来完成我们的应用</li>
<li>任何应用都可以抽象成一个组件树（Vue官方有图）</li>
</ul>
</li>
<li><h5 id="全局组件与局部组件"><a href="#全局组件与局部组件" class="headerlink" title="全局组件与局部组件"></a>全局组件与局部组件</h5><ul>
<li><p>Vue.extend()来编写组件的构造器，但是现在用的很少了，一般直接使用语法糖</p>
<pre><code>const myComponent = Vue.extend({
    template: 
    `
        &lt;div&gt;lalalalal&lt;/div&gt;
    `
})
Vue.component(&apos;cp1&apos;, myComponent)  #这里注册</code></pre></li>
<li><p>通过Vue.component(‘标签名’,组件)来注册的组件为全局组件</p>
</li>
<li><p>在Vue示例当中，也就是new Vue({components:})里边注册的组件为局部组件</p>
</li>
<li><p>组件注册的语法糖</p>
<ul>
<li><p>就是省略Vue.extend()</p>
<pre><code>Vue.component(&apos;cp1&apos;, {
    template: 
    `
        &lt;div&gt;lalalalal&lt;/div&gt;
    `
})</code></pre></li>
</ul>
</li>
<li><p>v-bind不能识别驼峰，要将驼峰进行转换，mustache是可以识别驼峰的</p>
</li>
</ul>
</li>
<li><h4 id="组件之间传值"><a href="#组件之间传值" class="headerlink" title="#组件之间传值"></a>#组件之间传值</h4><ul>
<li><p>父传子：在子组件的props中定义数据（也可以称之为变量），然后在使用的时候绑定即可</p>
<pre><code>例如：你在子组件中定义了name
props: {
    name: String  //这里的String是限制传过来的数据类型，可以不写
}
或者
props: {
    name: {
        type: String,
        default: 这是默认值
    }
}
然后在使用的地方加上name属性即可，例如cpn组件
&lt;cpn name=&apos;我是一个字符串&apos;&gt;&lt;/cpn&gt;
&lt;cpn :name=&apos;父组件中的属性&apos;&gt;&lt;/cpn&gt;     //使用v-bind来绑定父组件中的属性</code></pre></li>
<li><p>子传父：例如子组件为<cpn>。 使用自定义事件，this.$emit(‘传递的名称’, 传递的参数)，然后在组件进行监听&lt;cpn @传递的名称=’父组件的函数’&gt;  </p>
<pre><code>this.$emit(&apos;btnClick&apos;, item)
&lt;cpn @btnClick=&apos;cpnClick(item)&apos;&gt;    
#(item)可以省略，系统默认把子组件传递的参数传给父组件
#其实这里也是不能用驼峰的，但是脚手架里貌似可以用</code></pre><p>例如，点击button时向父组件传递数据</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;button @click=&quot;btnClick&quot;&gt;&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
methods: {
    btnClick() {
        this.$emit(&apos;随便起的名称&apos;, 这是数据)
    }
}

&lt;cpn @随便起的名称=&quot;父组件的函数(这里是数据)&quot;&gt;&lt;/cpn&gt;</code></pre></li>
</ul>
</li>
</ul>
<h3 id="5-父子组件间的访问方式"><a href="#5-父子组件间的访问方式" class="headerlink" title="5. 父子组件间的访问方式"></a>5. 父子组件间的访问方式</h3><pre><code>有时候父组件需要直接访问子组件，而不是使用props通信的方式，子组件需要直接访问父组件或者根组件</code></pre><ul>
<li><h5 id="父组件访问子组件"><a href="#父组件访问子组件" class="headerlink" title="父组件访问子组件"></a>父组件访问子组件</h5><ul>
<li><p>$children 在父组件的methods里边任意的函数里边this.$children即可获取子组件，返回的是一个数组（在开发时一般不使用这个方法，只有我们需要拿所有子组件时才可能会用，一般使用$refs）</p>
</li>
<li><p>$refs 这个需要在子组件加一个ref属性，然后再在methods里边调用，默认时为空[]</p>
<pre><code>&lt;cpn ref=&apos;aaa&apos;&gt;&lt;/cpn&gt;
this.$refs.aaa</code></pre></li>
</ul>
</li>
<li><h5 id="子组件访问父组件"><a href="#子组件访问父组件" class="headerlink" title="子组件访问父组件"></a>子组件访问父组件</h5><ul>
<li>$parent 用的更少，因为不好复用，不建议使用，在子组件里this.$parent,</li>
<li>$root 访问根组件</li>
</ul>
</li>
</ul>
<h3 id="6-插槽"><a href="#6-插槽" class="headerlink" title="6. 插槽"></a>6. 插槽</h3><ul>
<li><h5 id="slot基本使用"><a href="#slot基本使用" class="headerlink" title="slot基本使用"></a>slot基本使用</h5><ul>
<li><p><slot></slot> 如果在插槽中放东西，就是设置默认值，例如:</p>
<pre><code>&lt;slot&gt;&lt;button&gt;&lt;/button&gt;&lt;/slot&gt;</code></pre><p>如果在使用组件时，没有使用插槽，就会显示默认值，使用了，就显示你想要的值</p>
</li>
</ul>
</li>
<li><h5 id="具名插槽slot"><a href="#具名插槽slot" class="headerlink" title="具名插槽slot"></a>具名插槽slot</h5><ul>
<li><slot name=''></slot>，在使用时要给使用的地方加slot属性，例如 <span slot='这里是我们插槽的名字'></span></li>
</ul>
</li>
<li><h5 id="作用域插槽slot"><a href="#作用域插槽slot" class="headerlink" title="作用域插槽slot"></a>作用域插槽slot</h5><ul>
<li><p>父组件替换插槽里边的标签，但是内容是由子组件来提供， 例如cpn组件里边有一个languages的list</p>
<pre><code>&lt;cpn&gt;
    &lt;template slot=&apos;具名插槽&apos; slot-scope=&apos;myData&apos;&gt;  #这里的slot是可选选项，也就是说，作用域插槽可以用到具名插槽里边，myData也相当于是一个变量名称，可以随意定
        &lt;span&gt;{{myData.languages}}&lt;/span&gt;   #在这里使用这种形来调用子组件中的数据
    &lt;/template&gt;
&lt;/cpn&gt;

&lt;template id=&apos;cpn&apos;&gt;
    &lt;slot :data=&apos;languages&apos;&gt;&lt;/slot&gt;         #这里的data可以为任意名称，这里相当于声明一个变量
&lt;/template&gt;

cpn: {
    template: &quot;#cpn&quot;
    data: {
        return {
            languages : [&apos;java&apos;,&apos;java&apos;,&apos;java&apos;]
        }
    }
}</code></pre></li>
</ul>
</li>
</ul>
<h3 id="7-模块化开发"><a href="#7-模块化开发" class="headerlink" title="7. 模块化开发"></a>7. 模块化开发</h3><ul>
<li><h5 id="ES5模块化"><a href="#ES5模块化" class="headerlink" title="ES5模块化"></a>ES5模块化</h5><ul>
<li>ES5没有模块化，所以使用匿名函数的解决方案</li>
</ul>
</li>
<li><h5 id="常见的模块化规范"><a href="#常见的模块化规范" class="headerlink" title="常见的模块化规范"></a>常见的模块化规范</h5><ul>
<li><p>CommonJS、AMD、CMD、ES6的Modules</p>
</li>
<li><p>CommenJS(Webpack和Node.js用的多)：</p>
<ul>
<li><p>导出：</p>
<pre><code>module.exports = {
    flat: true,
    test(a, b){
        return a + b
    }
}</code></pre></li>
<li><p>导入：</p>
<pre><code>let obj = require(&apos;xxx.js&apos;) 
let {flat, tent} = require(&apos;xxx.js&apos;) 也可以直接获取</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><h5 id="ES6的模块化"><a href="#ES6的模块化" class="headerlink" title="ES6的模块化"></a>ES6的模块化</h5><ul>
<li><p>模块化就是在script标签里边的type属性定义为module，然后在该js文件里边export导出，在使用的地方import导入即可，例如: import {name} from ‘xxx.js’</p>
  <script type="module"></script>
</li>
<li><p>export default： 某些情况下，某个模块包含某个功能，我们并不希望给这个功能命名，而且让导入者自己命名，这时候我们就可以使用export default，<strong>一个js文件中只能有一个export default不允许存在多个，并且它后边只能跟一个值或对象</strong>，这里再使用import时可以不用使用{}了，直接为： import 我自己的命名 from ‘xxx.js’</p>
</li>
<li><p>当我们需要导入的东西太多时，例如:</p>
<pre><code>import {name,age,aaa,bbb,ccc,ddd} from &apos;aaa.js&apos;</code></pre><p>  我们可以使用</p>
<pre><code>import * as myName from &apos;aaa/js&apos;
myName.name</code></pre></li>
</ul>
</li>
</ul>
<h3 id="8-Webpack"><a href="#8-Webpack" class="headerlink" title="8. Webpack"></a>8. Webpack</h3><ul>
<li><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><ul>
<li><p>项目中要使用node依赖包时，要使用npm init命令安装依赖，这时候系统会生成package.json</p>
</li>
<li><p>webpack进行打包时，要有一个入口文件，例如main.js，在这个里边对你使用的各个文件，各个模块进行使用或者导入，然是在使用webpack对入口文件进行打包，webpack会自动处理与入口文件有关的各个模块各个依赖，然后进行打包，打包完成之后，webpack会生成一个js，在你想使用的页面中，使用打包后的js即可</p>
<pre><code>require(&apos;./css/normal.css&apos;)
require(&apos;./css/special.less&apos;)
const {param1, param2} = require(./js/abc.js)  param1和param2为接收的变量</code></pre></li>
</ul>
</li>
</ul>
<pre><code>- webpack.config.js是webpack的配置文件，在里边对其进行配置，包括entry，output，loader等

        const path = require(&apos;path&apos;)
        module.exports = {
            entry: &apos;.src/main.js&apos;,
            output: {
                // path: 这里必须是绝对地址，path是node的一个库，__dirname是获取本文件的绝对路径，path.resolve是拼接路径
                path: path.resolve(__dirname, &apos;dist&apos;)
                filename: &apos;bundle.js&apos;
            }   
        }

- package.json里的scripts里边定义的指令，优先使用本地库，如果没有本地库才去找全局库，在所有cmd中，都优先使用全局库，所以当我们想使用本地库时，在package.json里边定义指令即可
- npm install webpack --save-dev (--save-dev 是开始时依赖的意思，打包之后不用)</code></pre><ul>
<li><h5 id="核心为loader，可以在官方文档里边查找使用方法，用来处理各个文件，进行打包"><a href="#核心为loader，可以在官方文档里边查找使用方法，用来处理各个文件，进行打包" class="headerlink" title="核心为loader，可以在官方文档里边查找使用方法，用来处理各个文件，进行打包"></a>核心为loader，可以在官方文档里边查找使用方法，用来处理各个文件，进行打包</h5><ul>
<li>webpack 使用多个loader时，它是从右向左读取的</li>
<li>url-loader 在使用时，options里边有一个limit选项，这里边限制了图片的大小，如果小于这个限制，url-loader会把图片编译成base64格式进行使用，大于这个限制还需要下载一个file-loader</li>
<li>ES6 To ES5     <strong>babel-loader 脚手架里会有详细配置</strong></li>
<li>vue<ul>
<li>npm install vue-loader vue-template-compiler –save-dev 安装 </li>
<li>再到 webpack.config.js里边进行配置</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="plugin-在js文件里添加版权信息，webpack-BannerPlugin"><a href="#plugin-在js文件里添加版权信息，webpack-BannerPlugin" class="headerlink" title="plugin 在js文件里添加版权信息，webpack.BannerPlugin"></a>plugin 在js文件里添加版权信息，webpack.BannerPlugin</h5><pre><code>const webpack = require(&apos;webpack&apos;)
module.exports = {
    plugins: [
        new webpack.BannerPlugin(&apos;最终版权归xxx所有&apos;)
    ]
}</code></pre></li>
<li><h5 id="HtmlWebpackPlugin-插件"><a href="#HtmlWebpackPlugin-插件" class="headerlink" title="HtmlWebpackPlugin 插件"></a>HtmlWebpackPlugin 插件</h5><ul>
<li><p>在dist文件（我们发布的文件）里边自动生成一个index.html文件（可以使用指定模板）</p>
</li>
<li><p>将打包的标签自动添加到body中的script标签当中</p>
</li>
<li><p>安装</p>
<pre><code>npm install html-webpack-plugin --save-dev</code></pre></li>
<li><p>使用</p>
<pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)
module.exports = {
    plugins: [
        new webpack.BannerPlugin(&apos;最终版权归xxx所有&apos;)
        new HtmlWebpackPlugin()  //也可以有参数
        new HtmlWebpackPlugin({
            template: &apos;index.html&apos;  //根据index.html来生成，他会在当前的配置文件webpack.config.js所在的目录下找index.html，然后作为模板来生成
        })
    ]
}   </code></pre></li>
<li><p>js压缩的plugin</p>
<ul>
<li>uglifyjs-webpack-plugin</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="webpack-dev-server搭建本地服务器"><a href="#webpack-dev-server搭建本地服务器" class="headerlink" title="webpack-dev-server搭建本地服务器"></a>webpack-dev-server搭建本地服务器</h5><ul>
<li><p>这个本地服务器基于node.js，内部使用express框架</p>
</li>
<li><p>安装： npm install webpack-dev-server –save-dev</p>
</li>
<li><p>配置：</p>
<pre><code>module.exports = {
    devServer: {
        contentBase: &apos;./dist&apos;,      //要服务于那个文件夹
        inline: true                //是否实时刷新
        port: 1234                  //还可以配置端口，默认为8080
    }
}</code></pre></li>
<li><p>使用： 在package.json的scripts里边加上</p>
<pre><code>&quot;scripts&quot;: {
    &quot;serve&quot;: &quot;webpack-dev-server --open&quot;    //--open的作用是在跑完webpack-dev-server后，自动打开网页
}</code></pre></li>
</ul>
</li>
<li><h5 id="给文件夹起别名"><a href="#给文件夹起别名" class="headerlink" title="给文件夹起别名"></a>给文件夹起别名</h5><ul>
<li><p>在webpack.base.config.js里边的resolve属性的alias属性里边起别名</p>
<pre><code>resolve: {
    alias: {
        &apos;@&apos;: resolve(&apos;src&apos;)         //相当于给src起了别名为@，当我们使用/src/name时可以使用@/name
    }
}</code></pre><p>  在组件的script里边可以直接使用 import aaa from ‘@/name’<br>  <strong>注意：</strong>当我们的路径在dom里边使用，比如img里边，因为是src，所以不能直接使用，要使用~</p>
<pre><code>&lt;img src=&quot;~@/name&quot;&gt;</code></pre></li>
</ul>
</li>
</ul>
<h3 id="9-Vue-CLI"><a href="#9-Vue-CLI" class="headerlink" title="9. Vue CLI"></a>9. Vue CLI</h3><ul>
<li><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul>
<li>现在一般情况是使用的都是3.x的版本，通过 npm install @vue/cli -g来安装</li>
<li>如果即想用2的模板进行创建，也想用3的，就需要拉取2的模板，使用 npn install @vue/cli-init -g来进行安装</li>
</ul>
</li>
<li><h5 id="Vue-CLI2初始化项目"><a href="#Vue-CLI2初始化项目" class="headerlink" title="Vue CLI2初始化项目"></a>Vue CLI2初始化项目</h5><ul>
<li><p>指令：</p>
<pre><code>vue init webpack myProject</code></pre></li>
<li><p>配置项：</p>
<ul>
<li>Project name: package.json中的项目的名称，直接敲回车的话，默认为初始化的名字</li>
<li>Project description: 项目描述，保存在package.json中</li>
<li>Author</li>
<li>Vue build: 使用哪个版本的vue<ul>
<li>Runtime-only版本不能使用template，可能会导致项目不能运行，<ul>
<li>优点：它更小，运行效率更高，性能更高</li>
</ul>
</li>
<li>Runtime + Compiler 适合大多数使用者</li>
<li><strong>区别</strong>： <ul>
<li>main.js里边有区别，compiler使用了template，runtime-only使用了render箭头函数，自动生成时为h函数(本质为createElement函数，参数有三个(‘标签名’，{标签的属性}, [标签的内容]))</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>                    createElement(&apos;div&apos;, {class: &apos;box&apos;}, [&apos;hello&apos;, createElement(...)])   //内容里边可以继续嵌套
                    createElement(cpn)      //也可以直接放入一个组件效果一样，但是因为省略的ast步骤，效率更高

            - compiler里边的vue的运行过程：template -&gt; ast(abstract syntax tree抽象语法树) -&gt; render函数 -&gt; virtual DOM -&gt; real DOM(UI)
            - runtime-only的运行过程为： render函数 -&gt; virtual DOM -&gt; real DOM(UI)
            - 对比的话，only的性能更高，vue内部的代码量更少（因为它不需要写template -&gt; ast(abstract syntax tree抽象语法树) -&gt; render函数的处理的代码），runtime-only的.vue文件里边的template不需要使用template -&gt;ast，而是由vue-template-compiler这个库自己帮我们解析成了render函数
    + vue-router: 
    + ESLint: 是否使用ESLint对代码进行规范（ESLint当代码不规范时，编译直接报错）
    + unit test: 单元测试
    + e2e test with Nightwatch: end to end 使用Nightwatch进行端到端测试
- **package-lock.json**：记录node_modules里安装的真实版本，在package.json（这里只会规定一个大概的版本）里边有时候要求的安装版本与node_modules里安装的会不同，这里进行记录
- static文件：在build后，会原封不动的复制到dist文件当中</code></pre><ul>
<li><h5 id="Vue-CLI3初始化项目"><a href="#Vue-CLI3初始化项目" class="headerlink" title="Vue CLI3初始化项目"></a>Vue CLI3初始化项目</h5><ul>
<li><p>指令：</p>
<pre><code>vue create myProject</code></pre></li>
<li><p>配置项(按空格是选择或者取消)：</p>
<ul>
<li>please pick a preset<ul>
<li>default(babel, ESlint)</li>
<li>Manually</li>
</ul>
</li>
<li>自己看吧。。。</li>
</ul>
</li>
<li><p>public文件夹：在build后，原封不动的复制到dist当中</p>
</li>
<li><p>Vue CLI3的配置文件的修改方式：</p>
<ul>
<li>Vue UI：图形化界面进行修改</li>
<li>node_modules/@vue/cli-service/webpack.config.js，进去你会发现一个require(‘./lib/Service’)你会发现各种各样的配置</li>
<li>vue.config.js：在你当前这个项目的目录下创建这个文件，名字是固定的，在build时会进行合并</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><ul>
<li>如果箭头函数中只有一行代码，那么它会自动把这行代码返回</li>
<li>箭头函数中this与正常的function定义不同</li>
</ul>
</li>
</ul>
<h3 id="10-Vue-router"><a href="#10-Vue-router" class="headerlink" title="10. Vue-router"></a>10. Vue-router</h3><ul>
<li><h5 id="SPA页面（单页面富应用，-simple-page-web-application，前端路由阶段）"><a href="#SPA页面（单页面富应用，-simple-page-web-application，前端路由阶段）" class="headerlink" title="SPA页面（单页面富应用， simple page web application，前端路由阶段）"></a>SPA页面（单页面富应用， simple page web application，前端路由阶段）</h5><ul>
<li>核心为:改变url整体页面不刷新</li>
</ul>
</li>
<li><h5 id="如何实现改变url，页面不刷新"><a href="#如何实现改变url，页面不刷新" class="headerlink" title="如何实现改变url，页面不刷新"></a>如何实现改变url，页面不刷新</h5><ul>
<li><p>更改url的hash，例如：</p>
<pre><code>www.baidu.com
console:  location.hash = &apos;aaa&apos;
result: www.baidu.com/aaa，但是页面不会刷新</code></pre></li>
<li><p>H5里边的history模式:</p>
<ul>
<li>history.pushState({}, ‘’, ‘aaa’)<br>history.back()<br>history.forward()<br>这两个可以配套，可以返回<br>history.go()  注：history.go(-1) == history.back(),history.go(1) == history.forward()</li>
<li>history.replaceState({}, ‘’, ‘bbb’)  这个不能返回</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h5><ul>
<li><p>to属性： 定义要指向的url</p>
<pre><code>&lt;router-link to=&apos;/home&apos;&gt;&lt;/router-link&gt;</code></pre></li>
<li><p>tag: router-link最终默认渲染成a标签，我们可以手动改为别的</p>
<pre><code>&lt;router-link tag=&apos;div&apos; or tag=&apos;button&apos;&gt;&lt;/router-link&gt;</code></pre></li>
<li><p>router-link当使用h5的history时，默认使用pushState(可以使用网页中的后撤键)，我们可以手动设置成replaceState(禁止用户使用后撤键)</p>
<pre><code>&lt;router-link to=&apos;/home&apos; tag=&apos;li&apos; replace&gt;&lt;/router-link&gt;</code></pre></li>
<li><p>active-class:两个roter处于活跃状态时，添加的class(很少用)</p>
<pre><code>&lt;router-link to=&apos;/home&apos; tag=&apos;li&apos; replace active-class=&apos;myClass&apos;&gt;&lt;/router-link&gt;</code></pre></li>
<li><p>在组件当中使用时，是使用$router属性进行修改</p>
<pre><code>this.$router.push(&apos;/home&apos;)</code></pre></li>
<li><p>动态路由的使用：例如，要在home页面后边动态的拼接url，就需要在映射里边进行修改</p>
<pre><code>routes: [
    {
        path: &apos;/home/:userId&apos;       //这个userId可以为任意名字
        component： Home
    }
]</code></pre><p>  然后在调用的时候用v-bind进行绑定就行</p>
<pre><code>&lt;router-link :to=&quot;&apos;/home&apos; + 我们data里边的数据名称&quot;&gt;&lt;/router-link&gt;</code></pre><p>  我们如何获取home后边的数据，并使用到我们的vue当中：使用this.$route</p>
<pre><code>可以在methods或者computed里边
this.$route.params.userId         //这里为什么是userId，是因为上边我们写的名字为userId，加入是abc，这里就是abc</code></pre><p>  this.$router和this.$route的区别：</p>
<pre><code>+ this.$router:是我们在router.js里边我们const rou = new Router({})的常量
+ this.$route是当前我们在使用哪个路由，也就是哪个路由处于活跃状态</code></pre></li>
</ul>
</li>
<li><h5 id="路由的懒加载"><a href="#路由的懒加载" class="headerlink" title="路由的懒加载"></a>路由的懒加载</h5><ul>
<li><p>vueCLI3，经过npm run build打包之后的js文件分为三个：</p>
<ul>
<li>app.哈希码.js：业务逻辑代码，也就是我们自己写的代码</li>
<li>manifest.哈希码.js：底层的支撑，比如说对ES6，CommonJS的支撑等</li>
<li>vendor.哈希码.js：项目里边引用的第三方的东西，例如vue和vue-router等</li>
</ul>
</li>
<li><p>为什么使用懒加载</p>
<ul>
<li>项目在打包时，js文件可能会非常大，同时加载可能会影响加载速度，所以需要懒加载（用到时再加载）</li>
<li>如果把不同的路由对应的组件分割成不同的代码块，当路由被访问时再加载对应的组件，效率就更好了（也就是用到时再加载）</li>
<li>懒加载做的事情就是将路由对应的组件包装成一个又一个的小的js文件，用到时再加载</li>
</ul>
</li>
<li><p>代码实现：</p>
<pre><code>原来是：
import Home from &apos;./components/home&apos;
routes: [
    {
        path: &apos;/home&apos;
        component： Home
    }
]

懒加载：
routes: [
    {
        path: &apos;/home&apos;
        component： () =&gt; import(&apos;./components/home&apos;)
    }
]
或者(这样写的话更简洁，方便统一管理)：
const Home = () =&gt; import(&apos;./components/home&apos;)
routes: [
    {
        path: &apos;/home&apos;
        component： Home
    }
]</code></pre></li>
</ul>
</li>
<li><h5 id="路由的嵌套："><a href="#路由的嵌套：" class="headerlink" title="路由的嵌套："></a>路由的嵌套：</h5><ul>
<li><p>假如我们想在/home后边添加子路由/news，需要这样配置(子路由里边也可以设置默认值，设置redirect)：</p>
<pre><code>routes: [
    {
        path: &apos;/home&apos;
        component： () =&gt; import(&apos;./components/home&apos;)
        children: [
            {
                path: &apos;news&apos;        //注意，这里不需要加/
                component: import(&apos;./components/news&apos;)
            },
        ]
    }
]</code></pre><p>  然后需要到Home组件当中再添加一个router-view，并且router-link也要注意写全，而不是只写news</p>
<pre><code>&lt;router-link to=&apos;/home/news&apos;&gt;&lt;/router-link&gt;
&lt;router-view&gt;&lt;/router-view&gt;</code></pre></li>
</ul>
</li>
<li><h5 id="路由的参数传递"><a href="#路由的参数传递" class="headerlink" title="路由的参数传递"></a>路由的参数传递</h5><ul>
<li><p>第一种方式就是上边的动态路由</p>
</li>
<li><p>query方式</p>
<ul>
<li><p>要更改router-link中的to属性，用v-bind绑定，然后绑定一个{}对象，里边有path和query属性</p>
<pre><code>&lt;router-link :to=&quot;{path: &apos;/user&apos;, query:{name:&apos;lalala&apos;, age: 18}}&quot;&gt;&lt;/router-link&gt;</code></pre><p>  然后在user.vue里边使用$route.query.age等来取出来进行使用</p>
</li>
</ul>
</li>
<li><p>在组件的methods中使用，也是使用this.$router.push()，然后在push里边输入上边的对象即可</p>
<p>  methods: {</p>
<pre><code>这是我的方法名() {
    return this.$router.push({
        path: &apos;/user&apos;, 
        query: {
            name:&apos;lalala&apos;, 
            age: 18 
        }
    })
}</code></pre><p>  }</p>
</li>
</ul>
</li>
<li><h5 id="导航守卫（去看看vue-router的官网）"><a href="#导航守卫（去看看vue-router的官网）" class="headerlink" title="导航守卫（去看看vue-router的官网）"></a>导航守卫（去看看vue-router的官网）</h5></li>
<li><h5 id="keep-alive及其他问题"><a href="#keep-alive及其他问题" class="headerlink" title="keep-alive及其他问题"></a>keep-alive及其他问题</h5><ul>
<li>vue组件除了created和beforeMouted等属性，还有activated和deactivated属性，不过这两个属性只有在组件被keep-alive包起来时才能使用</li>
<li>它有两个非常重要的属性：<ul>
<li>include：字符串或正则表达式，只有匹配的组件会被缓存</li>
<li>exclude：字符串或正则表达式，任何匹配的组件都不会被缓存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="11-符号的解释，例如-router"><a href="#11-符号的解释，例如-router" class="headerlink" title="11. $符号的解释，例如$router"></a>11. $符号的解释，例如$router</h3><ul>
<li><p><strong>所有的vue组件都继承自vue类的原型</strong></p>
<ul>
<li><p>例如，当你给vue类的原型，添加一个属性时，那么所有的组件都可以使用这个属性</p>
<pre><code>Vue.prototype.test = function(){
    console.log(&apos;这是测试&apos;)
} </code></pre><p>  那么你在任意的组件里边都可以使用this.test()进行调用，一般来说都使用$test来防止冲突</p>
</li>
</ul>
</li>
</ul>
<h3 id="12-Promise"><a href="#12-Promise" class="headerlink" title="12. Promise"></a>12. Promise</h3><ul>
<li><h5 id="Promise的基本使用："><a href="#Promise的基本使用：" class="headerlink" title="Promise的基本使用："></a>Promise的基本使用：</h5><ul>
<li><p>什么情况下会用到promise？</p>
<ul>
<li>一般情况下，是有异步操作时，使用promise对异步操作进行封装</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>Promise接收的参数是一个函数</li>
<li>resolve和reject都是函数</li>
<li>then和catch接收的也都是函数</li>
</ul>
</li>
<li><p>链式调用使用方式：</p>
<pre><code>new Promise((resolve, reject) =&gt; {
    setTimeout((data) =&gt; {      //这里用setTimeout来模拟异步操作
        resolve(data)           //用resolve函数来把data传给then函数
        reject(&apos;error data&apos;)    //数据获取失败，使用reject
    }, 1000)
}).then(data =&gt; {               //当数据获取成功时，使用resolve函数，然后执行then函数
    console.log(data)
    return new Promise((resolve, reject) =&gt; {
        //来这里进行嵌套调用
    })
}).catch(data =&gt; {
    console.log(data)       //这里打印的就是error data这个字符串
}) </code></pre></li>
</ul>
</li>
<li><h5 id="Promise的链式调用"><a href="#Promise的链式调用" class="headerlink" title="Promise的链式调用"></a>Promise的链式调用</h5><ul>
<li><p>简化过程：</p>
<pre><code>new Promise((resolve, reject) =&gt; {
    setTimeout((data) =&gt; {      
        resolve(data)           
        reject(&apos;error data&apos;)   
    }, 1000)
}).then(data =&gt; {               
    console.log(data)       //拿到data后，想对data进行操作，比如拼接&apos;111&apos;
    return new Promise((resolve, reject) =&gt; {       //这里的reject没用到，所以可以省略，写成resolve =&gt; {}
        resolve(data + &apos;111&apos;)
    })
}).then(res =&gt; {
    console.log(res)
})</code></pre></li>
<li><p>上边的过程进行简化(Promise提供了resolve方法，当然也有reject方法，可以在catch里边使用)</p>
<pre><code>new Promise((resolve, reject) =&gt; {
    setTimeout((data) =&gt; {      
        resolve(data)           
        reject(&apos;error data&apos;)   
    }, 1000)
}).then(data =&gt; {               
    console.log(data)       
    return Promise.resolve(data + &apos;111&apos;)
}).then(res =&gt; {
    console.log(res)
})</code></pre></li>
<li><p>再次简化(Promise自动对返回的数据使用Promise.resolve进行封装，reject不行)</p>
<pre><code>new Promise((resolve, reject) =&gt; {
    setTimeout((data) =&gt; {      
        resolve(data)           
        reject(&apos;error data&apos;)   
    }, 1000)
}).then(data =&gt; {               
    console.log(data)       
    return data + &apos;111&apos;
}).then(res =&gt; {
    console.log(res)
})</code></pre></li>
</ul>
</li>
</ul>
<h3 id="13-axios"><a href="#13-axios" class="headerlink" title="13. axios"></a>13. axios</h3><ul>
<li><h5 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h5><ul>
<li><p>axios(config)</p>
<pre><code>axios({
    url:
    params:
    method:
    timeout:
    ...
})</code></pre></li>
<li><p>axios.get()</p>
</li>
<li><p>axios.post()</p>
</li>
<li><p>axios.delete()</p>
</li>
<li><p>axios.head()</p>
</li>
<li><p>axios.put()</p>
</li>
<li><p>axios.patch()</p>
</li>
</ul>
</li>
<li><h5 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h5><ul>
<li><p>做一个功能，需要两个请求都到达后，才向下进行</p>
</li>
<li><p>axios.all(list)：</p>
<ul>
<li><p>参数：需要传入一个数组，需要几个同时到达，就在数组里边写几个数据请求</p>
</li>
<li><p>返回：一个数组</p>
<pre><code>axios.all([axios(), axios()]).then(res =&gt; {
    res[0].操作
    res[1].操作
})</code></pre><p>  还有一个方法axios.spread可以将结果展开</p>
<pre><code>axios.all([axios(), axios()])
.then(axios.spread((res1, res2) =&gt; {
    res1.操作
    res2.操作
}))</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><h5 id="关于配置config的相关信息"><a href="#关于配置config的相关信息" class="headerlink" title="关于配置config的相关信息"></a>关于配置config的相关信息</h5><ul>
<li>axios.default.baseURL巴拉巴拉的</li>
<li>baseURL</li>
<li>timeout</li>
<li>method</li>
<li>transformRequest</li>
<li>transformResponse</li>
<li>headers</li>
<li>params</li>
</ul>
</li>
<li><h5 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h5><ul>
<li><p>为了防止总是使用全局的axios产生混乱，或者处理不同请求的不同配置，需要为请求创建实例</p>
</li>
<li><p>axios.create(config)</p>
<pre><code>const instance1 = axios.create({
                        baseURL:
                        timeout:
                    })
instance1({
    url: &quot;&quot;
}).then(res =&gt; {}).catch(err =&gt; {}) //catch捕捉异常</code></pre></li>
</ul>
</li>
<li><h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5><ul>
<li><p>用于我们发送请求后，或者得到响应后，进行对应的处理</p>
</li>
<li><p>请求拦截:例如有一个instance1实例，那么拦截器代码为：</p>
<ul>
<li><p>instance1.interceptors.request.use(config =&gt; {}, err =&gt; {}) 拦截请求</p>
</li>
<li><p>use()代表你要使用这个拦截器，他有两个参数，两个参数都为函数</p>
<ul>
<li>config:请求成功时使用的函数</li>
<li>err: 请求失败时的函数</li>
</ul>
</li>
<li><p>使用：</p>
<pre><code>instance1.interceptors.request.use(config =&gt; {
    console.log(config)
    return config   // **当你使用拦截器时，一定要返回，否则就被拦截掉了，无法请求到数据**
}, err =&gt; {})</code></pre></li>
<li><p>请求拦截的作用：</p>
<ul>
<li>比如我们在请求中，想添加那个圆圈动画，可以在config中添加，</li>
<li>或者对config进行规范，这就是拦截器的作用</li>
<li><strong>比如我们请求数据时，需要携带token，比如需要用户先登录，就可以先拦截下来，然后跳转到用户登录界面，进行登录，再继续请求数据</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>响应拦截：</p>
<ul>
<li><p>instance1.interceptors.response 拦截响应</p>
</li>
<li><p>使用：</p>
<pre><code>instance1.interceptors.response().use(res =&gt; {
    一系列处理。。。。
    return res //记得返回，否则请求的地方就拿不到结果
    或者：
    return res.data //只返回data，这样可以去掉服务器给我们的其他的乱七八糟的东西
}, err =&gt; {})</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="14-Vuex"><a href="#14-Vuex" class="headerlink" title="14. Vuex"></a>14. Vuex</h3><ul>
<li><h5 id="Vuex简介"><a href="#Vuex简介" class="headerlink" title="Vuex简介"></a>Vuex简介</h5><ul>
<li>什么是Vuex？<ul>
<li>Vuex是专为Vus.js开发的一个状态管理模式</li>
<li>所谓状态管理模式就是，有很多个组件需要共享多个变量，那么把这多个变量放到一个对象里边，然后把这个对象放到vue的顶层的示例里边，给所有组件共享（我们也可以自己写，但是Vuex是响应式的，自己实现比较麻烦）。</li>
<li><strong>Vuex里边储存的一定是需要在多个页面共享的状态</strong></li>
</ul>
</li>
<li>什么样的状态需要在多个组件之间共享，而不是使用父子组件传讯的方式？（token）<ul>
<li>大型项目里边的状态，比如说：用户的登陆状态、地理位置信息、购物车状态等，这些状态就需要统一的地方保存和管理，并且还是响应式的</li>
<li>token：在后台请求数据时，需要携带token（令牌）</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="Vuex的使用"><a href="#Vuex的使用" class="headerlink" title="Vuex的使用"></a>Vuex的使用</h5><ul>
<li><p>创建过程(真正创建的不是new Vuex而是 new Vuex.Store)：</p>
<pre><code>import Vue from &apos;vue&apos;
import Vuex from &apos;vuex&apos;

Vue.use(Vuex)

const store = new Vuex.Store({
    state:{},       //存储数据状态
    mutations:{},   //定义方法，
    actions:{},     //用来处理异步操作
    getters:{},     //类似于组件里边的计算属性
    modules:{}      //划分模块，针对不同的模块再进行管理
})

export default store</code></pre><p>  &lt;然后再main class=”js里边导入并注册”&gt;&lt;/然后再main&gt;</p>
</li>
<li><p>state的修改过程：</p>
<ul>
<li>Vue components -(dispathc)-&gt; Actions -(commit)-&gt; Mutations -(mutate)-&gt; State -(Render)-&gt; Vue components 或者<br>Vue components –&gt; Mutations –&gt; State –&gt; Vue components</li>
<li>Actions:它的作用是用来处理异步操作，异步网络请求，因为为了追踪State是在哪里被修改了，官方给Mutations开发了一个Chrome插件Devtools，而这个插件只能监听同步操作，无法监听异步，所以才需要Actions</li>
</ul>
</li>
<li><p>核心模块详解：</p>
<ul>
<li><p>state：保存状态，推荐使用单一状态树，即只创建一个store</p>
<ul>
<li>单一状态树：就是建议在store.js里边只有一个new store</li>
</ul>
</li>
<li><p>getters：类似于组件里边的计算属性computed，它也有默认的state参数，还可以有另外一个参数就是getters，也就是这个getters本身，用来获取getters里边的方法，例如sum(state, getters)，<strong>也就是说，不管你前两个参数叫什么名字，第一个参数代表的一定是state，第二个一定是getters</strong>，所以说如果想给getters传参，要使用其他方法：</p>
<pre><code>getters: {
    sum(state) {
        return function(这是我想传入的参数){
            //在这里使用参数即可
        }
    }
}</code></pre><p>  因为返回的是个函数，所以在调用的时候以函数的形式使用，并传入参数即可</p>
<pre><code>this.$store.getters.sum(我是参数)</code></pre></li>
<li><p>mutations：这里边的方法会有一个默认参数为state，也就是上边这个state，比如说定义sum(),它相当于sun(state)</p>
<ul>
<li><p>使用mutations里边定义的函数的方法：</p>
<pre><code>store.commit(&apos;mutations里边定义的方法名&apos;)
components里边为this.$store.commit(&apos;sum&apos;)</code></pre></li>
<li><p>传参方式：</p>
<pre><code>首先：
sum (state, num){           //在这里定义并使用
    sum += num
}
store.commit(&apos;sum&apos;, count)  //先这里进行传参</code></pre></li>
<li><p>另外一种提交方式：</p>
<pre><code>store.commit({
    type: &apos;sum&apos;,
    count: count
})</code></pre><p>  使用这种方式的时候就要注意，传过去的参数，不是一个数值，而是一个对象，在函数里边使用时，要用num.count才可以    </p>
</li>
<li><p>类型常量（去看一眼视频吧，理解了下边挺简单的，或者看官网)：就是单独创建了一个文件，在里边定义函数名并导出，然后后按照第二种方法的声明方式，在mutations里边和使用的地方进行统一，例如</p>
<pre><code>export const MYPARAM = &apos;myparam&apos;
import {MYPARAM} from &apos;xx.js&apos;
原来函数定义为：
myparam(){

}
因为可以定义为
[&apos;myparam&apos;](){

}
所以现在可以为：
[MYPARAN](){

}</code></pre><p>  这样的话，在使用的时候，方法名得到了统一，哪怕我在export const MYPARAM = ‘myparam’写错了，对我的代码也没有影响，这是官方推荐形式</p>
<ul>
<li><p>方法的定义不光可以使用：</p>
<pre><code>方法名(){

}</code></pre><p>  也可以使用</p>
<pre><code>[&apos;方法名&apos;](){

}</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>action：因为Devtool不能监听异步操作，所以所有异步操作都要在action里边进行</p>
<pre><code>函数声明和mutations一样，只不过默认参数不一样：
sum(context, param){        //这里的param是用来接收参数，没有传参可以不写，这里的context可以看成我们声明的store，也就是$store
    setTimeout(() =&gt; {
        //这里调用mutations里边的函数！注意这里不能跳过mutations直接操作state
        context.state.myData = &apos;lalalal&apos;    //直接修改了所以是错误的
        context.commit(&apos;mutations里边的方法&apos;)    //正确写法
    }, 1000)
}</code></pre><p>  在使用时，应该是</p>
<pre><code>this.$store.dispatch(&apos;sum&apos;, &apos;这第二个参数，是我要传递的参数，可以不写&apos;)</code></pre><ul>
<li><p>如何判断里边的异步函数已经完成，可以从action里边传回一个Promise(可以看看视频，我觉得天秀)：</p>
<pre><code>sum(context, myParam){
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            context.commit(&apos;mutations里边的方法&apos;)
            console.log(myParam)

            resolve(&apos;这是我想传回去的参数&apos;)       
        }, 1000)    //神奇的地方来了，不在这里写then，而是在调用的地方
    })
}

this.$store.dispatch(&apos;sum&apos;, &apos;这是参数&apos;).then(res =&gt; {
    console.log(&apos;里边的异步已经执行完了&apos;)
    console.log(res)    //这是resolve给的数据
})</code></pre><p>  <strong>解释</strong>：因为then函数是接在new Promise后边的，而sum函数return的就是一个new Promise，所以我们的this.$store.dispatch(‘sum’, ‘这是参数’)这句代码执行完之后，相当于被替换成了new Promise()，所以它后边可以接then（天秀！！！）</p>
</li>
</ul>
</li>
<li><p>modules：当你想要进行模块划分时，在这里边进行，举例：</p>
<pre><code>const moduleC = {
    state:{},
    mutations:{},
    actions:{},
    getters:{},
    modules:{}
}

modules: {
    a: {
        state:{},
        mutations:{},
        actions:{},
        getters:{},
        modules:{}
    },
    b: {
        state:{},
        mutations:{},
        actions:{},
        getters:{},
        modules:{}
    },
    c: moduleC
}</code></pre><p>  这样来进行你想要的划分，使用方法：</p>
<ul>
<li><p>state：modules里边的state在使用时，Vue是将它封装成一个对象，放在根state里边的，所以使用是： $store.state.a.name</p>
</li>
<li><p>mutations：modules里边的mutations的命名不能与根store里边的命名重复，因为它的使用是：$store.commit(‘modules里边的mutations的方法名’)，直接调用，如果重复了会有冲突</p>
</li>
<li><p>getters：modules里边的getters，可以直接调用自己本模块的getters，也可以直接调用根模块的getters</p>
</li>
<li><p>actions：与根模块相比，他的context多了两个属性：rootGetters和rootState</p>
</li>
<li><p>对象的解构：</p>
<pre><code>const obj = {
    name: &apos;123&apos;,
    age: 19,
    height:1.88
}

解构的使用办法为：
const {name, height, age} = obj     //它是按名字取值的，不是按顺序</code></pre></li>
</ul>
</li>
<li><p>目录结构：</p>
<ul>
<li>将mutations和actions等，抽成单个的文件，然后再store.js里边导入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><h5 id="Vuex的数据响应式"><a href="#Vuex的数据响应式" class="headerlink" title="Vuex的数据响应式"></a>Vuex的数据响应式</h5><ul>
<li><p>什么样的数据是响应式</p>
<ul>
<li><p><strong>必须是提前在store中初始化好的属性</strong>，也就是说我们后边通过一些方法添加的属性，不是响应式的，例如:</p>
<pre><code>store.state.info[&apos;address&apos;] = &apos;lalala&apos;      //address是我们新添加的属性</code></pre></li>
<li><p>我们可以使用Vue的方法来使我们添加的数据变为响应式</p>
<ul>
<li>Vue.set(要更改的数据, 下标或属性, value)     //当要改的数据为数组时，第二个参数为下标</li>
<li>Vue.delete(要更改的数据, 下标或属性)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 Lightman</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#AutoEncoder','#连读发音','#Flex','#CNN','#GAN','#JavaScript','#协作开发软件','#LSTM','#Q网络','#GCN','#Ted','#Python','#算法','#沉默的大多数','#电影台词',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
